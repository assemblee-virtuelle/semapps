{"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AIEA,MAAM,sCAAgB,OAAO,aAAa;IACxC,MAAM,cAAE,UAAU,eAAE,WAAW,EAAE,GAAG;IAEpC,IAAI,EAAE,MAAM,IAAI,EAAE,GAAG,MAAM,WAAW;IAEtC,IAAI,CAAC,MAAM,MAAM,IAAI,MAAM,CAAC,kBAAkB,EAAE,YAAY,CAAC;IAE7D,KAAK,EAAE,GAAG,KAAK,EAAE,IAAI,IAAI,CAAC,MAAM;IAEhC,sFAAsF;IACtF,gDAAgD;IAChD,IAAI,IAAI,CAAC,WAAW,KAAK,aACvB,OAAO,MAAM,CAAA,GAAA,uCAAK,EAAE,OAAO,CAAC,MAAM;IAGpC,OAAO;AACT;IAEA,2CAAe;;;ADlBf,MAAM,qCAAe,CAAA,SAAU,OAAO,YAAY;QAChD,MAAM,aAAE,SAAS,EAAE,GAAG;QACtB,MAAM,YAAY,SAAS,CAAC,WAAW;QAEvC,IAAI,CAAC,WAAW,MAAM,IAAI,MAAM,CAAC,SAAS,EAAE,WAAW,gCAAgC,CAAC;QAExF,MAAM,OAAO,MAAM,CAAA,GAAA,wCAAY,EAAE,OAAO,EAAE,EAAE;QAE5C,yDAAyD;QACzD,IAAI,UAAU,IAAI,EAAE,YAAY;YAC9B,KAAK,MAAM,kBAAkB,UAAU,IAAI,EAAE,cAAc,EAAE,CAC3D,IAAI,IAAI,CAAC,eAAe,IAAI,CAAC,MAAM,OAAO,CAAC,IAAI,CAAC,eAAe,GAC7D,IAAI,CAAC,eAAe,GAAG;gBAAC,IAAI,CAAC,eAAe;aAAC;QAGnD;QAEA,wCAAwC;QACxC,0CAA0C;QAC1C,2DAA2D;QAC3D,WAAW;QACX,sBAAsB;QACtB,0CAA0C;QAC1C,sCAAsC;QACtC,UAAU;QACV,cAAc;QACd,uEAAuE;QACvE,0CAA0C;QAC1C,oCAAoC;QACpC,sBAAsB;QACtB,8FAA8F;QAC9F,UAAU;QACV,QAAQ;QACR,MAAM;QACN,IAAI;QAEJ,OAAO;kBAAE;QAAK;IAChB;IAEA,2CAAe;;;;AErCf,MAAM,+BAAS,CAAC,IAAmC,GAAG,WAAW,EAAE,OAAO,YAAY;AACtF,MAAM,uCAAiB,CAAC,IACtB,GAAG,iBAAiB,aAAa,GAAG,iBAAiB;AAEvD,MAAM,+CAAyB,CAAC;IAC9B,MAAM,YAAY,OAAO,IAAI,CAAC,OAAO,WAAW,EAAE,IAAI,CAAC,CAAA,MAAO,OAAO,WAAW,CAAC,IAAI,CAAC,gBAAgB;IACtG,IAAI,aAAa,OAAO,WAAW,CAAC,UAAU,CAAC,gBAAgB,EAC7D,OAAO,CAAA,GAAA,wCAAM,EAAE,OAAO,WAAW,CAAC,UAAU,CAAC,OAAO,EAAE,OAAO,WAAW,CAAC,UAAU,CAAC,gBAAgB;IAEtG,OAAO;AACT;AAEA,MAAM,mCAAa,OAAO,SAAe;IACvC,MAAM,sBAAsB,6CAAuB;IACnD,IAAI,CAAC,qBAAqB,MAAM,IAAI,MAAM;IAE1C,MAAM,WAAW,MAAM,OAAO,UAAU,CAAC,qBAAqB;QAC5D,QAAQ;QACR,MAAM;QACN,SAAS,IAAI,QAAQ;YACnB,gBAAgB,QAAQ,IAAI;QAC9B;IACF;IAEA,IAAI,SAAS,MAAM,KAAK,KACtB,OAAO,SAAS,OAAO,CAAC,GAAG,CAAC;IAE9B,OAAO;AACT;AAEA,MAAM,oCAAc,OAAO,eAAyB;IAClD,OAAO,QAAQ,GAAG,CAChB,cAAc,GAAG,CAAC,CAAA,OAChB,OAAO,UAAU,CAAC,MAAM;YACtB,QAAQ;QACV;AAGN;AAEA;;;CAGC,GACD,MAAM,uCAAiB,OAAO,QAA2B;IACvD,MAAM,gBAA0B,EAAE;IAClC,MAAM,gBAAgB;QAAE,GAAG,MAAM;IAAC;IAElC,KAAK,MAAM,YAAY,OAAO,IAAI,CAAC,QAAS;QAC1C,MAAM,QAAQ,MAAM,CAAC,SAAS;QAC9B,IAAI,MAAM,OAAO,CAAC,QAChB,IAAK,IAAI,IAAI,GAAG,IAAI,MAAM,MAAM,EAAE,IAAK;YACrC,MAAM,YAAY,KAAK,CAAC,EAAE;YAC1B,IAAI,6BAAO,YAAY;gBACrB,IAAI,qCAAe,YACjB,cAAc,IAAI,CAAC,UAAU,YAAY;gBAE3C,aAAa,CAAC,SAAS,CAAC,EAAE,GAAG,MAAM,iCAAW,UAAU,OAAO,EAAE;YACnE,OAAO,IAAI,qCAAe,YAAY;gBACpC,cAAc,IAAI,CAAC,UAAU,YAAY;gBACzC,aAAa,CAAC,SAAS,CAAC,EAAE,GAAG;YAC/B;QACF;aACK,IAAI,6BAAO,QAAQ;YACxB,IAAI,qCAAe,QACjB,cAAc,IAAI,CAAC,MAAM,YAAY;YAEvC,aAAa,CAAC,SAAS,GAAG,MAAM,iCAAW,MAAM,OAAO,EAAE;QAC5D,OAAO,IAAI,qCAAe,QAAQ;YAChC,cAAc,IAAI,CAAC,MAAM,YAAY;YACrC,aAAa,CAAC,SAAS,GAAG;QAC5B;IACF;IAEA,OAAO;uBACL;uBACA;IACF;AACF;IAEA,2CAAe;IACb,QAAQ;IACR,QAAQ;AACV;;;;AGvFA,MAAM,6CAAuB,CAAC,MAAM;IAClC,OAAO,OAAO,IAAI,CAAC,aAAa,IAAI,CAAC,CAAA;QACnC,OAAO,WAAW,CAAC,IAAI,CAAC,KAAK;IAC/B;AACF;IAEA,2CAAe;;;ADJf,MAAM,uCAAiB,CAAC,WAAW;IACjC,OAAQ;QACN,KAAK;YACH,OAAO,CAAA,GAAA,wCAAmB,EAAE,WAAW;QACzC,KAAK;YACH,OAAO,CAAA,GAAA,wCAAmB,EAAE,OAAO;QACrC,KAAK;YACH,OAAO,CAAA,GAAA,wCAAmB,EAAE,cAAc;QAC5C;YACE,OAAO;IACX;AACF;AAEA,8CAA8C;AAC9C,6DAA6D;AAC7D,MAAM,wCAAkB,CAAC,YAAY;IACnC,IAAI,MAAM,OAAO,CAAC,aAAa;QAC7B,IAAI,WAAW,QAAQ,CAAC,SACtB,OAAO,OAAO,IAAI,CAAC;QAErB,OAAO,WAAW,GAAG,CAAC,CAAA,YAAa,qCAAe,WAAW;IAC/D;IACA,IAAI,OAAO,eAAe,UAAU;QAClC,IAAI,eAAe,QACjB,OAAO,OAAO,IAAI,CAAC;QAErB,IAAI,eAAe,WAAW;YAC5B,MAAM,mBAAmB,CAAA,GAAA,wCAAmB,EAAE,WAAW;YACzD,OAAO,OAAO,IAAI,CAAC,aAAa,MAAM,CAAC,CAAA,YAAa,cAAc;QACpE;QACA,OAAO;YAAC,qCAAe,YAAY;SAAa;IAClD;IACA,yBAAyB;IACzB,OAAO;AACT;IAEA,2CAAe;;;ADlCf,MAAM,gDAA0B,CAC9B,OACA,YACA;IAEA,MAAM,aAAa,CAAC;IACpB,MAAM,qBAA+B,EAAE;IAEvC,MAAM,mBAAmB,CAAA,GAAA,wCAAc,EAAE,YAAY;IAErD,OAAO,IAAI,CAAC,aACT,MAAM,CAAC,CAAA,gBAAiB,WAAW,CAAC,cAAc,CAAC,UAAU,EAC7D,OAAO,CAAC,CAAA;QACP,OAAO,IAAI,CAAC,WAAW,CAAC,cAAc,CAAC,UAAU,IAAI,CAAC,GAAG,OAAO,CAAC,CAAA;YAC/D,IAAI,CAAC,oBAAoB,iBAAiB,QAAQ,CAAC,eACjD,OAAO,IAAI,CAAC,WAAW,CAAC,cAAc,CAAC,UAAU,AAAC,CAAC,aAAa,EAAE,OAAO,CAAC,CAAA;gBACxE,IAAI,MAAM,QAAQ,CAAC,OACjB,WAAW,CAAC,cAAc,CAAC,UAAU,AAAC,CAAC,aAAa,CAAC,KAAK,CAAC,GAAG,CAAC,CAAA;oBAC7D,MAAM,eAAe,CAAA,GAAA,wCAAM,EAAE,WAAW,CAAC,aAAa,CAAC,OAAO,EAAE;oBAEhE,mDAAmD;oBACnD,IAAI,CAAC,mBAAmB,QAAQ,CAAC,eAAe;wBAC9C,mBAAmB,IAAI,CAAC;wBAExB,IAAI,CAAC,UAAU,CAAC,cAAc,EAAE,UAAU,CAAC,cAAc,GAAG,EAAE;wBAC9D,UAAU,CAAC,cAAc,CAAC,IAAI,CAAC;oBACjC;gBACF;YAEJ;QAEJ;IACF;IACF,OAAO;AACT;IAEA,2CAAe;;;AJnCf,MAAM,qCAAe,CAAA,SAAU,OAAO,YAAY;QAChD,MAAM,eAAE,WAAW,aAAE,SAAS,cAAE,UAAU,eAAE,WAAW,EAAE,GAAG;QAC5D,MAAM,YAAY,SAAS,CAAC,WAAW;QAEvC,IAAI,CAAC,WAAW,MAAM,CAAC,SAAS,EAAE,WAAW,gCAAgC,CAAC;QAE9E,MAAM,UAAU,IAAI;QAEpB,IAAI;QACJ,IAAI;QACJ,IAAI,UAAU,MAAM,EAAE,WAAW;YAC/B,YAAY,OAAO,IAAI,CAAC,UAAU,MAAM,CAAC,SAAS,CAAC,CAAC,EAAE;YACtD,eAAe,CAAA,GAAA,wCAAM,EAAE,WAAW,CAAC,UAAU,CAAC,OAAO,EAAE,OAAO,MAAM,CAAC,UAAU,MAAM,CAAC,SAAS,CAAC,CAAC,EAAE;QACrG,OAAO;YACL,YAAY,UAAU,MAAM,EAAE,UAAU,OAAO,IAAI,CAAC,aAAa,IAAI,CAAC,CAAA,MAAO,WAAW,CAAC,IAAI,CAAC,OAAO,KAAK;YAC1G,IAAI,CAAC,WAAW,MAAM,IAAI,MAAM;YAEhC,MAAM,aAAa,CAAA,GAAA,wCAAsB,EAAE,UAAU,KAAK,EAAE;gBAAC;aAAU,EAAE;YACzE,2EAA2E;YAC3E,MAAM,aAAa,OAAO,IAAI,CAAC;YAE/B,IAAI,CAAC,cAAc,WAAW,MAAM,KAAK,GACvC,MAAM,IAAI,MAAM,CAAC,wBAAwB,EAAE,KAAK,SAAS,CAAC,UAAU,KAAK,EAAE,iBAAiB,EAAE,UAAU,CAAC;YAC3G,IAAI,WAAW,MAAM,GAAG,KAAK,UAAU,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC,MAAM,GAAG,GAC9D,MAAM,IAAI,MACR,CAAC,4CAA4C,EAAE,KAAK,SAAS,CAAC,UAAU,KAAK,EAAE,WAAW,EAAE,UAAU,CAAC;YAE3G,eAAe,UAAU,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC,EAAE;QAC7C;QAEA,IAAI,OAAO,IAAI,EAAE;YACf,IAAI,UAAU,aAAa,EAAE;gBAC3B,IAAI,MAAM,OAAO,CAAC,UAAU,aAAa,CAAC,KAAK,GAC7C,QAAQ,GAAG,CAAC,QAAQ,UAAU,aAAa,CAAC,KAAK,CAAC,GAAG,CAAC,CAAA,IAAK,OAAO,IAAI,CAAC,EAAE,EAAE,IAAI,CAAC;qBAEhF,QAAQ,GAAG,CAAC,QAAQ,OAAO,IAAI,CAAC,UAAU,aAAa,CAAC,KAAK,CAAC;;YAIlE,iCAAiC;YACjC,MAAM,iBAAE,aAAa,EAAE,GAAG,MAAM,CAAA,GAAA,wCAAU,EAAE,MAAM,CAAC,OAAO,IAAI,EAAE;YAChE,OAAO,IAAI,GAAG;YAEd,MAAM,EAAE,SAAS,eAAe,EAAE,GAAG,MAAM,WAAW,cAAc;gBAClE,QAAQ;yBACR;gBACA,MAAM,KAAK,SAAS,CAAC;oBACnB,YAAY;oBACZ,SAAS,UAAU,KAAK;oBACxB,GAAG,OAAO,IAAI;gBAChB;YACF;YAEA,kCAAkC;YAClC,MAAM,cAAc,gBAAgB,GAAG,CAAC;YACxC,OAAO,MAAM,CAAA,GAAA,wCAAK,EAAE,QAAQ,YAAY;gBAAE,IAAI;YAAY;QAC5D;QACA,IAAI,OAAO,EAAE,EAAE;YACb,QAAQ,GAAG,CAAC,gBAAgB;YAE5B,MAAM,WAAW,cAAc;gBAC7B,QAAQ;yBACR;gBACA,MAAM,CAAC;;uBAEU,EAAE,aAAa,gBAAgB,EAAE,OAAO,EAAE,CAAC;MAC5D,CAAC;YACH;YAEA,mEAAmE;YACnE,OAAO,MAAM,CAAA,GAAA,wCAAK,EAAE,QAAQ,YAAY;gBAAE,IAAI,OAAO,EAAE;YAAC;QAC1D;IACF;IAEA,2CAAe;;;;AO3Ef,MAAM,qCAAe,CAAC,SAA0B,OAAO,YAAoB;QACzE,MAAM,cAAE,UAAU,EAAE,GAAG;QAEvB,MAAM,WAAW,CAAC,EAAE,OAAO,EAAE,CAAC,CAAC,EAAE;YAC/B,QAAQ;QACV;QAEA,IAAI,OAAO,IAAI,EAAE,eACf,MAAM,CAAA,GAAA,wCAAU,EAAE,MAAM,CAAC,OAAO,IAAI,CAAC,aAAa,EAAE;QAGtD,OAAO;YAAE,MAAM;gBAAE,IAAI,OAAO,EAAE;YAAC;QAAE;IACnC;IAEA,2CAAe;;;AClBf,MAAM,yCAAmB,CAAA,SAAU,OAAO,YAAY;QACpD,MAAM,cAAE,UAAU,EAAE,GAAG;QACvB,MAAM,MAAM,EAAE;QAEd,KAAK,MAAM,MAAM,OAAO,GAAG,CACzB,IAAI;YACF,MAAM,WAAW,IAAI;gBACnB,QAAQ;YACV;YACA,IAAI,IAAI,CAAC;QACX,EAAE,OAAO,GAAG;QACV,6CAA6C;QAC/C;QAGF,OAAO;YAAE,MAAM;QAAI;IACrB;IAEA,2CAAe;;;AClBf,MAAM,uCAAiB,CAAA,SAAU;QAC/B,OAAO,OAAO,WAAW;IAC3B;IAEA,2CAAe;;;ACJf,MAAM,sCAAgB,CAAA,SAAU;QAC9B,OAAO,OAAO,SAAS;IACzB;IAEA,2CAAe;;;;;AGJf,MAAM,gCAAU,CAAI;IAClB,4DAA4D;IAC5D,IAAI,CAAC,OACH,OAAO,EAAE;IAEX,gBAAgB;IAChB,IAAI,MAAM,OAAO,CAAC,QAChB,OAAO;IAET,iCAAiC;IACjC,OAAO;QAAC;KAAM;AAChB;IAEA,2CAAe;;;ADuBf,MAAM,4CAAsB,CAAC;IAC3B,MAAM,eAAe,AAAC,UAAmC,IAAI,IAAI,AAAC,SAAoC,CAAC,QAAQ;IAC/G,OAAO,MAAM,OAAO,CAAC,gBAAgB,aAAa,QAAQ,CAAC,mBAAmB,iBAAiB;AACjG;AAEA,MAAM,iCAAW,CAAC;IAChB,OAAO,OAAO,QAAQ,OAAO,QAAQ,YAAY,CAAC,MAAM,OAAO,CAAC;AAClE;AAEA,MAAM,wCAAkB,OACtB,YACA,QACA,cAAE,UAAU,eAAE,WAAW,EAAiB;IAE1C,MAAM,gBAAgB,OAAO,MAAM,CAAC,YAAY,IAAI;IAEpD,MAAM,gBAAgB,cAAc,GAAG,CAAC,CAAA,eACtC,WAAW,cACR,IAAI,CAAC,OAAO,QAAE,IAAI,EAAE;YACnB,MAAM,eAA6B;YAEnC,4EAA4E;YAC5E,gDAAgD;YAChD,IAAI,YAAY,CAAC,WAAW,KAAK,aAC/B,OAAO,CAAA,GAAA,uCAAK,EAAE,OAAO,CAAC,cAAc;YAGtC,OAAO;QACT,GACC,IAAI,CAAC,CAAC;YACL,IAAI,CAAC,0CAAoB,OACvB,MAAM,IAAI,MAAM,CAAC,EAAE,aAAa,uBAAuB,CAAC;YAG1D,OAAO,CAAA,GAAA,wCAAM,EAAE,IAAI,CAAC,eAAe,EAAE,GAAG,CAAc,CAAA,WAAa,CAAA;oBACjE,YAAY,IAAI,CAAC,WAAW;oBAC5B,GAAG,QAAQ;gBACb,CAAA;QACF;IAGJ,sCAAsC;IACtC,MAAM,UAAU,MAAM,QAAQ,GAAG,CAAC;IAClC,IAAI,YAAY,QAAQ,IAAI;IAE5B,YAAY,UAAU,GAAG,CAAC,CAAA;QACxB,SAAS,EAAE,GAAG,SAAS,EAAE,IAAI,QAAQ,CAAC,MAAM;QAC5C,OAAO;IACT;IAEA,0BAA0B;IAC1B,MAAM,UAAuB,OAAO,MAAM;IAE1C,sFAAsF;IACtF,IAAI,QAAQ,CAAC,EAAE;QACb,QAAQ,IAAI,GAAG,QAAQ,CAAC;QACxB,OAAO,QAAQ,CAAC;IAClB;IAEA,4DAA4D;IAC5D,IAAI,QAAQ,WAAW,IAAI,MAAM,OAAO,CAAC,QAAQ,WAAW,GAAG;QAC7D,MAAM,aAAa,QAAQ,WAAW;QACtC,MAAM,sBAAsB;YAAC;SAAK;QAElC,YAAY,UAAU,GAAG,CAAC,CAAA;YACxB,OAAO,OAAO,IAAI,CAAC,UAChB,MAAM,CAAC,CAAA,MAAO,WAAW,QAAQ,CAAC,QAAQ,oBAAoB,QAAQ,CAAC,MACvE,MAAM,CACL,CAAC,kBAAkB;gBACjB,gBAAgB,CAAC,IAAI,GAAG,QAAQ,CAAC,IAAI;gBACrC,OAAO;YACT,GACA;gBAAE,YAAY,EAAE;YAAC;QAEvB;IACF;IAEA,IAAI,OAAO,IAAI,CAAC,SAAS,MAAM,CAAC,CAAA,IAAK,CAAC;YAAC;YAAe;SAAW,CAAC,QAAQ,CAAC,IAAI,MAAM,GAAG,GACtF,YAAY,UAAU,MAAM,CAAC,CAAA;QAC3B,sBAAsB;QACtB,IAAI,QAAQ,CAAC,EACX,OAAO,OAAO,MAAM,CAAC,UAAU,IAAI,CAAC,CAAA;YAClC,IAAI,CAAC,+BAAS,iBAAiB;gBAC7B,MAAM,cAAc,MAAM,OAAO,CAAC,kBAAkB,iBAAiB;oBAAC;iBAAe;gBACrF,OAAO,YAAY,IAAI,CAAC,CAAA;oBACtB,IAAI,OAAO,UAAU,UACnB,OAAO,MAAM,WAAW,GAAG,SAAS,CAAC,OAAO,QAAQ,CAAC,QAAQ,CAAC,CAAE,WAAW,GAAG,SAAS,CAAC;oBAE1F,OAAO;gBACT;YACF;YACA,OAAO;QACT;QAGF,sBAAsB;QACtB,MAAM,oBAAoB,OAAO,IAAI,CAAC,SAAS,MAAM,CAAC,CAAA,IAAK,CAAC;gBAAC;gBAAe;gBAAY;aAAI,CAAC,QAAQ,CAAC;QAEtG,OAAO,kBAAkB,KAAK,CAAC,CAAA;YAC7B,IAAI,QAAQ,CAAC,UAAU,EAAE;gBACvB,MAAM,cAAqB,MAAM,OAAO,CAAC,QAAQ,CAAC,UAAU,IAAI,QAAQ,CAAC,UAAU,GAAG;oBAAC,QAAQ,CAAC,UAAU;iBAAC;gBAC3G,OAAO,YAAY,IAAI,CACrB,CAAC,QAAe,OAAO,UAAU,YAAY,MAAM,QAAQ,CAAC,OAAO,CAAC,UAAU;YAElF;YAEA,OAAO;QACT;IACF;IAGF,UAAU;IACV,IAAI,OAAO,IAAI,EACb,YAAY,UAAU,IAAI,CAAC,CAAC,GAAG;QAC7B,IAAI,CAAC,CAAC,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,OAAO,IAAI,CAAC,KAAK,CAAC,EAAE;YAChD,IAAI,OAAO,IAAI,CAAC,KAAK,KAAK,OACxB,OAAO,CAAC,CAAC,OAAO,IAAI,CAAC,KAAK,CAAC,CAAC,aAAa,CAAC,CAAC,CAAC,OAAO,IAAI,CAAC,KAAK,CAAC;YAEhE,OAAO,CAAC,CAAC,OAAO,IAAI,CAAC,KAAK,CAAC,CAAC,aAAa,CAAC,CAAC,CAAC,OAAO,IAAI,CAAC,KAAK,CAAC;QAChE;QACA,OAAO;IACT;IAGF,aAAa;IACb,MAAM,QAAQ,UAAU,MAAM;IAE9B,IAAI,OAAO,UAAU,EACnB,YAAY,UAAU,KAAK,CACzB,AAAC,CAAA,OAAO,UAAU,CAAC,IAAI,GAAG,CAAA,IAAK,OAAO,UAAU,CAAC,OAAO,EACxD,OAAO,UAAU,CAAC,IAAI,GAAG,OAAO,UAAU,CAAC,OAAO;IAItD,OAAO;QAAE,MAAM;eAAW;IAAM;AAClC;IAEA,2CAAe;;;;AG7Kf,MAAM,sCAAgB,CAAA;IACpB,IAAI,aAAa,CAAC;IAClB,IAAI;IACJ,IAAI,YAAY;QACd,KAAK,MAAM,aAAa,WAAY;YAClC,IAAI,UAAU,QAAQ,CAAC,MACrB,aAAa,UAAU,KAAK,CAAC,KAAK,OAAO;iBAEzC,aAAa;gBAAC;aAAU;YAE1B,aAAa;gBACX,GAAG,UAAU;gBACb,GAAG,WAAW,MAAM,CAClB,CAAC,aAAa,YAAe,CAAA;wBAC3B,CAAC,UAAU,EAAE;4BACX,UAAU;4BACV,GAAG,WAAW;wBAChB;oBACF,CAAA,GACA,CAAC,EACF;YACH;QACF;QACA,OAAO;IACT;AACF;IAEA,2CAAe;;;;;AG3Bf,MAAM,sCAAgB,CAAC,MAAM;IAC3B,IAAI,KAAK,UAAU,CAAC,cAAc,KAAK,UAAU,CAAC,aAChD,mCAAmC;IACnC,OAAO;IAET,IAAI,SAAS,KACX,eAAe;IACf,OAAO;IAET,MAAM,CAAC,QAAQ,MAAM,GAAG,KAAK,KAAK,CAAC;IACnC,IAAI,OAAO;QACT,MAAM,WAAW,WAAW,IAAI,CAAC,CAAA,WAAY,SAAS,MAAM,KAAK;QACjE,IAAI,UACF,OAAO,SAAS,GAAG,GAAG;QAExB,MAAM,IAAI,MAAM,CAAC,8BAA8B,EAAE,OAAO,CAAC;IAC3D,OACE,MAAM,IAAI,MAAM,CAAC,WAAW,EAAE,KAAK,4DAA4D,CAAC;AAEpG;IAEA,2CAAe;;;ADlBf,MAAM,uCAAiB,CAAA,QAAU,CAAC,QAAQ,EAAE,GAAG,MAAM,OAAO,CAAC,SAAS,QAAQ;QAAC;KAAM;AAErF,2EAA2E;AAC3E,MAAM,kCAAY,CAAA,GAAA,4BAAK,EACrB,CAAA,GAAA,8BAAO,EAAE,OACT,CAAA,GAAA,+BAAQ,EAAE,oDACV,CAAA,GAAA,8BAAO,EAAE;AAGX,MAAM,uCAAiB,CAAC,YAAY;IAClC,IAAI;IACJ,IAAI,YAAY;QACd,cAAc,qCAAe,YAAY,GAAG,CAAC,CAAC,WAAW,IACvD,CAAA,GAAA,4BAAK,EAAE,CAAA,GAAA,8BAAO,EAAE,OAAO,CAAA,GAAA,+BAAQ,EAAE,CAAA,GAAA,wCAAY,EAAE,WAAW,cAAc,CAAA,GAAA,8BAAO,EAAE,CAAC,CAAC,EAAE,IAAI,EAAE,CAAC;QAE9F,OAAO;YACL,WAAW;gBAAC;mBAAc;aAAY;YACtC,OAAO;gBAAC;mBAAc,YAAY,GAAG,CAAC,CAAA,SAAW,CAAA;wBAAE,MAAM;wBAAY,UAAU;4BAAC;yBAAO;oBAAC,CAAA;aAAI;QAC9F;IACF;IACA,cAAc;QAAC,CAAA,GAAA,4BAAK,EAAE,CAAA,GAAA,8BAAO,EAAE,OAAO,CAAA,GAAA,8BAAO,EAAE,OAAO,CAAA,GAAA,8BAAO,EAAE;KAAO;IACtE,OAAO;QACL,WAAW;QACX,OAAO;IACT;AACF;IAEA,2CAAe;;;;;;AE1Bf,qGAAqG;AACrG,MAAM,qCAAe,CAAA;IACnB,MAAM,QAAQ,EAAE;IAChB,IAAI,YAAY;QACd,KAAK,MAAM,aAAa,WACtB,IAAI,UAAU,QAAQ,CAAC,MAAM;YAC3B,MAAM,YAAY,UAAU,KAAK,CAAC;YAClC,IAAK,IAAI,IAAI,GAAG,KAAK,UAAU,MAAM,EAAE,IACrC,MAAM,IAAI,CAAC,UAAU,KAAK,CAAC,GAAG,GAAG,IAAI,CAAC;QAE1C,OACE,MAAM,IAAI,CAAC;IAGjB;IACA,OAAO;AACT;AAEA,MAAM,8CAAwB,CAAA,OAAQ,CAAA,GAAA,4CAAE,EAAE;AAE1C,MAAM,sCAAgB,CAAA,OAAQ,KAAK,QAAQ,CAAC,QAAQ,KAAK,KAAK,CAAC,IAAI,CAAC,EAAE;AAEtE,MAAM,qCAAe,CAAA,OAAS,KAAK,QAAQ,CAAC,OAAO,KAAK,KAAK,CAAC,IAAI,CAAC,EAAE,GAAG;AAExE,MAAM,wCAAkB,CAAA,UACtB,QAAQ,GAAG,CAAC,CAAA;QACV,IAAI,UAAU,EAAE,KAAK;QACrB,MAAM,cAAc,QAAQ,IAAI,CAAC,CAAA,KAAM,EAAE,UAAU,KAAK,GAAG,IAAI;QAC/D,IAAI,gBAAgB,WAClB,UAAU,QAAQ,MAAM,CAAC,YAAY,KAAK,CAAC,EAAE;QAE/C,OAAO;YACL,MAAM;qBACN;QACF;IACF;AAEF,MAAM,6CAAuB,CAAC,YAAY,WAAW;IACnD,MAAM,UAAU,EAAE;IAClB,MAAM,QAAQ,mCAAa;IAE3B,IAAI,SAAS,cAAc,WAAW,MAAM,GAAG,GAAG;QAChD,KAAK,MAAM,QAAQ,MAAO;YACxB,MAAM,aAAa,oCAAc;YACjC,MAAM,YAAY,mCAAa;YAC/B,MAAM,UAAU,4CAAsB;YACtC,MAAM,gBAAgB,aAAa,4CAAsB,cAAc;YAEvE,MAAM,QAAQ;gBACZ,CAAA,GAAA,4BAAK,EAAE,CAAA,GAAA,8BAAO,EAAE,CAAC,CAAC,EAAE,cAAc,CAAC,GAAG,CAAA,GAAA,+BAAQ,EAAE,CAAA,GAAA,wCAAY,EAAE,WAAW,cAAc,CAAA,GAAA,8BAAO,EAAE,CAAC,CAAC,EAAE,QAAQ,CAAC;gBAC7G,CAAA,GAAA,4BAAK,EAAE,CAAA,GAAA,8BAAO,EAAE,CAAC,CAAC,EAAE,QAAQ,CAAC,GAAG,CAAA,GAAA,8BAAO,EAAE,CAAC,CAAC,EAAE,QAAQ,CAAC,GAAG,CAAA,GAAA,8BAAO,EAAE,CAAC,CAAC,EAAE,QAAQ,CAAC;aAChF;YAED,QAAQ,IAAI,CAAC;sBACX;4BACA;uBACA;gBACA,QAAQ,GAAG,oCAAoC;YACjD;QACF;QAEA,OAAO;YACL,WAAW,QAAQ,MAAM,GAAG,IAAI,QAAQ,GAAG,CAAC,CAAA,IAAK,EAAE,KAAK,EAAE,MAAM,CAAC,CAAC,KAAK,MAAQ,IAAI,MAAM,CAAC,QAAQ;YAClG,OAAO;gBACL,MAAM;gBACN,UAAU;oBAAC,UAAU,KAAK;uBAAK,sCAAgB;iBAAS;YAC1D;QACF;IACF;IACA,OAAO;QACL,WAAW;QACX,OAAO;IACT;AACF;IAEA,2CAAe;;;;AC7Ef,MAAM,uDAAiC,CAAC,OAAO;IAC7C,MAAM,YAAY;WAAI,UAAU,SAAS;KAAC;IAC1C,IAAI,QAAQ,CAAC;IACb,IAAI,QAAQ,GAAG;QACb,MAAM,eAAe,EAAE;QACvB,aAAa,IAAI,CAAC;YAAC,UAAU,KAAK;SAAC;QACnC,IAAK,IAAI,IAAI,GAAG,KAAK,OAAO,IAAK;YAC/B,UAAU,IAAI,CAAC,CAAA,GAAA,4BAAK,EAAE,CAAA,GAAA,8BAAO,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC,GAAG,CAAA,GAAA,8BAAO,EAAE,CAAC,CAAC,EAAE,IAAI,EAAE,CAAC,GAAG,CAAA,GAAA,8BAAO,EAAE,CAAC,CAAC,EAAE,IAAI,EAAE,CAAC;YACpF,aAAa,IAAI,CAAC;mBACb,YAAY,CAAC,aAAa,MAAM,GAAG,EAAE;gBACxC;oBACE,MAAM;oBACN,YAAY;wBACV,MAAM;wBACN,UAAU;wBACV,MAAM;4BAAC,CAAA,GAAA,8BAAO,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC;yBAAE;oBAC3B;gBACF;gBACA,CAAA,GAAA,4BAAK,EAAE,CAAA,GAAA,8BAAO,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC,GAAG,CAAA,GAAA,8BAAO,EAAE,CAAC,CAAC,EAAE,IAAI,EAAE,CAAC,GAAG,CAAA,GAAA,8BAAO,EAAE,CAAC,CAAC,EAAE,IAAI,EAAE,CAAC;aACtE;QACH;QACA,QAAQ;YACN,MAAM;YACN,UAAU;QACZ;IACF,OAAO,IAAI,UAAU,GACnB,QAAQ,UAAU,KAAK;SAEvB,MAAM,IAAI,MAAM;IAGlB,OAAO;mBAAE;eAAW;IAAM;AAC5B;IAEA,2CAAe;;;;;gDJ9BT;AAEN,MAAM,WAAE,6BAAO,aAAE,+BAAS,UAAE,4BAAM,YAAE,8BAAQ,EAAE,GAAG,CAAA,GAAA,+CAAU;AAE3D,MAAM,kCAAY,8CAAoB;AAEtC;AAEA,MAAM,2CAAqB;IAAC;IAAK;IAAe;IAAc;IAAmB;IAAY;CAAc;AAE3G,MAAM,yCAAmB,CAAC,cAAE,UAAU,UAAE,MAAM,aAAE,SAAS,cAAE,UAAU,EAAE;IACrE,MAAM,aAAa,OAAO,MAAM,EAAE,cAAc,UAAU,IAAI,EAAE;IAChE,MAAM,aAAa,OAAO,MAAM,EAAE,eAAe,UAAU,IAAI,EAAE;IACjE,MAAM,kBAAkB,OAAO,MAAM,EAAE,mBAAmB,UAAU,IAAI,EAAE,mBAAmB;IAC7F,MAAM,SAAS;QAAE,GAAG,UAAU,IAAI,EAAE,MAAM;QAAE,GAAG,OAAO,MAAM;IAAC;IAC7D,MAAM,YAAY,CAAA,GAAA,wCAAa,EAAE,YAAY;IAE7C,MAAM,iBAAiB;QACrB,WAAW;QACX,UAAU,UAAU,SAAS;QAC7B,OAAO,EAAE;QACT,MAAM;QACN,UAAU,OAAO,WAAW,CAAC,WAAW,GAAG,CAAC,CAAA,WAAY;gBAAC,SAAS,MAAM;gBAAE,SAAS,GAAG;aAAC;IACzF;IAEA,MAAM,iBAAiB;QACrB;YACE,MAAM;YACN,QAAQ,WAAW,GAAG,CAAC,CAAA,eAAiB,CAAA;oBAAE,iBAAiB,gCAAU;gBAAc,CAAA;QACrF;QACA,6BAAO,+BAAS,iBAAiB,gCAAU,sCAAsC,+BAAS;QAC1F;YACE,MAAM;YACN,YAAY;gBACV,MAAM;gBACN,UAAU;gBACV,MAAM;oBAAC,+BAAS;iBAAM;YACxB;QACF;KACD;IAED,IAAI,gBAAgB,EAAE;IAEtB,IAAI,UAAU,OAAO,IAAI,CAAC,QAAQ,MAAM,GAAG,GAAG;QAC5C,MAAM,kBAAkB,OAAO,WAAW,IAAI,OAAO,IAAI,CAAC,OAAO,WAAW,EAAE,MAAM,GAAG;QACvF,MAAM,oBAAoB,OAAO,CAAC,IAAI,OAAO,CAAC,CAAC,MAAM,GAAG;QAExD,IAAI,iBACF;;;;;;;;;;;;MAYA,GACA,6CAA6C;QAC7C,EAAE,CAAC,MAAM,CAAC,OAAO,WAAW,EAAE,OAAO,CAAC,CAAA;YACpC,cAAc,IAAI,CAAC;QACrB;QAGF,IAAI,mBACF,cAAc,IAAI,CAAC;YACjB,MAAM;YACN,UAAU;gBACR;oBACE,WAAW;oBACX,WAAW;wBAAC,+BAAS;qBAAM;oBAC3B,OAAO;wBACL,6BAAO,+BAAS,OAAO,+BAAS,OAAO,+BAAS;wBAChD;4BACE,MAAM;4BACN,YAAY;gCACV,MAAM;gCACN,UAAU;gCACV,MAAM;oCAAC,+BAAS;iCAAM;4BACxB;wBACF;wBACA;4BACE,MAAM;4BACN,YAAY;gCACV,MAAM;gCACN,UAAU;gCACV,MAAM;oCACJ;wCACE,MAAM;wCACN,UAAU;wCACV,MAAM;4CACJ;gDACE,MAAM;gDACN,UAAU;gDACV,MAAM;oDAAC,+BAAS;iDAAM;4CACxB;yCACD;oCACH;oCACA,8BAAQ,OAAO,CAAC,CAAC,WAAW,IAAI,IAAI,gCAAU;iCAC/C;4BACH;wBACF;qBACD;oBACD,MAAM;gBACR;aACD;QACH;QAGF,gBAAgB;QAChB,uGAAuG;QACvG,oHAAoH;QACpH,OAAO,OAAO,CAAC,QAAQ,OAAO,CAAC,CAAC,CAAC,WAAW,OAAO;YACjD,IAAI,CAAC,yCAAmB,QAAQ,CAAC,YAC/B,cAAc,OAAO,CACnB,6BACE,+BAAS,OACT,gCAAU,CAAA,GAAA,wCAAY,EAAE,WAAW,cACnC,gCAAU,CAAA,GAAA,wCAAY,EAAE,QAAQ;QAIxC;IACF;IAEA,cAAc;IACd,MAAM,kBAAkB,aACpB,CAAA,GAAA,wCAAmB,EAAE,YAAY,WAAW,cAC5C,CAAA,GAAA,wCAA6B,EAAE,iBAAiB;IAEpD,IAAI,mBAAmB,gBAAgB,SAAS,EAAE;QAChD,gBAAgB,cAAc,MAAM,CAAC,gBAAgB,KAAK;QAC1D,eAAe,QAAQ,GAAG,eAAe,QAAQ,CAAC,MAAM,CAAC,gBAAgB,SAAS;IACpF,OACE,cAAc,IAAI,CAAC,UAAU,KAAK;IAGpC,eAAe,KAAK,CAAC,IAAI,CACvB;QACE,MAAM;QACN,UAAU;YACR;YACA;gBACE,MAAM;gBACN,MAAM,gCAAU;gBAChB,UAAU;YACZ;SACD;IACH,GACA;QACE,MAAM;QACN,UAAU;YACR;YACA;gBACE,MAAM;gBACN,MAAM,gCAAU;gBAChB,UAAU;YACZ;SACD;IACH;IAGF,OAAO,gCAAU,SAAS,CAAC;AAC7B;IAEA,2CAAe;;;AF1Kf,MAAM,gCAAU,CAAC,GAAG;IAClB,OAAQ,OAAO;QACb,KAAK;YACH,OAAO,EAAE,aAAa,CAAC;QACzB,KAAK;QACL,KAAK;YACH,OAAO,IAAI;QACb;YACE,OAAO;IACX;AACF;AAEA,MAAM,6CAAuB,OAAO,YAAY,YAAY,QAAQ;IAClE,MAAM,eAAE,WAAW,aAAE,SAAS,cAAE,UAAU,eAAE,WAAW,cAAE,UAAU,EAAE,GAAG;IACxE,MAAM,YAAY,SAAS,CAAC,WAAW;IAEvC,MAAM,sBAAsB,OAAO,IAAI,CAAC,YAAY,GAAG,CACrD,CAAA,YACE,IAAI,QAAQ,CAAC,SAAS;YACpB,MAAM,aAAa,OAAO,MAAM,EAAE,cAAc,UAAU,IAAI,EAAE;YAEhE,0GAA0G;YAC1G,IACE,OAAO,MAAM,EAAE,eACd,CAAA,OAAO,OAAO,MAAM,CAAC,WAAW,KAAK,YAAY,OAAO,MAAM,CAAC,WAAW,YAAY,MAAK,GAE5F,OAAO,MAAM,CAAC,WAAW,GAAG,KAAK,KAAK,CAAC,mBAAmB,OAAO,MAAM,CAAC,WAAW;YAErF,MAAM,cAAc,CAAA,GAAA,wCAAe,EAAE;gBACnC,YAAY,UAAU,CAAC,UAAU;wBACjC;2BACA;4BACA;YACF;YAEA,WAAW,WAAW,CAAC,UAAU,CAAC,cAAc,EAAE;gBAChD,QAAQ;gBACR,MAAM;YACR,GACG,IAAI,CAAC,CAAC,QAAE,IAAI,EAAE;gBACb,8EAA8E;gBAC9E,+FAA+F;gBAC/F,2GAA2G;gBAC3G,MAAM,QACJ,cAAc,UAAU,IAAI,EAAE,2BAA2B,QACrD;oBACE,YAAY;oBACZ,SAAS,UAAU,KAAK;oBACxB,UAAU;oBACV,GAAG,CAAA,GAAA,wCAAY,EAAE,WAAW;gBAC9B,IACA;oBACE,YAAY;oBACZ,SAAS,UAAU,KAAK;gBAC1B;gBAEN,oFAAoF;gBACpF,OAAO,CAAA,GAAA,uCAAK,EAAE,KAAK,CAAC,MAAM,OAAO;oBAAE,WAAW;gBAAM;YACtD,GACC,IAAI,CAAC,CAAA;gBACJ,IAAI,WAAW,CAAC,MAAM,EAAE;oBACtB,MAAM,EAAE,YAAY,OAAO,EAAE,GAAG,MAAM,GAAG;oBACzC,cAAc;wBACZ,YAAY;wBACZ,UAAU;4BAAC;yBAAK;oBAClB;gBACF;gBACA,QACE,WAAW,CAAC,SAAS,CAAC,GAAG,CAAC,CAAA,WAAa,CAAA;wBAAE,YAAY,WAAW,CAAC,WAAW;wBAAE,GAAG,QAAQ;oBAAC,CAAA,MAAO,EAAE;YAEvG,GACC,KAAK,CAAC,CAAA,IAAK,OAAO;QACvB;IAGJ,kCAAkC;IAClC,IAAI,UAAU,MAAM,QAAQ,GAAG,CAAC;IAEhC,IAAI,QAAQ,MAAM,KAAK,GACrB,OAAO;QAAE,MAAM,EAAE;QAAE,OAAO;IAAE;IAE9B,iCAAiC;IACjC,UAAU,EAAE,CAAC,MAAM,IAAI;IAEvB,iEAAiE;IACjE,IAAI,aAAa,QAAQ,GAAG,CAAC,CAAA;QAC3B,KAAK,EAAE,GAAG,KAAK,EAAE,IAAI,IAAI,CAAC,MAAM;QAChC,OAAO;IACT;IAEA,iFAAiF;IACjF,IAAI,OAAO,IAAI,EACb,aAAa,WAAW,IAAI,CAAC,CAAC,GAAG;QAC/B,IAAI,CAAC,CAAC,OAAO,IAAI,CAAC,KAAK,CAAC,KAAK,aAAa,CAAC,CAAC,OAAO,IAAI,CAAC,KAAK,CAAC,KAAK,WAAW;YAC5E,IAAI,OAAO,IAAI,CAAC,KAAK,KAAK,OACxB,OAAO,8BAAQ,CAAC,CAAC,OAAO,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC,OAAO,IAAI,CAAC,KAAK,CAAC;YAE3D,OAAO,8BAAQ,CAAC,CAAC,OAAO,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC,OAAO,IAAI,CAAC,KAAK,CAAC;QAC3D;QACA,OAAO;IACT;IAEF,IAAI,OAAO,UAAU,EACnB,aAAa,WAAW,KAAK,CAC3B,AAAC,CAAA,OAAO,UAAU,CAAC,IAAI,GAAG,CAAA,IAAK,OAAO,UAAU,CAAC,OAAO,EACxD,OAAO,UAAU,CAAC,IAAI,GAAG,OAAO,UAAU,CAAC,OAAO;IAItD,OAAO;QAAE,MAAM;QAAY,OAAO,QAAQ,MAAM;IAAC;AACnD;IAEA,2CAAe;;;;AOlHf,MAAM,gDAA0B,CAAC,OAAO;IACtC,MAAM,aAAa,CAAC;IACpB,OAAO,IAAI,CAAC,OAAO,OAAO,CAAC,CAAA;QACzB,IAAI,WAAW,CAAC,UAAU,EAAE;YAC1B,UAAU,CAAC,UAAU,GAAG,EAAE;YAC1B,KAAK,CAAC,UAAU,CAAC,OAAO,CAAC,CAAA;gBACvB,UAAU,CAAC,UAAU,CAAC,IAAI,CAAC,CAAA,GAAA,wCAAM,EAAE,WAAW,CAAC,UAAU,CAAC,OAAO,EAAE;YACrE;QACF,OACE,MAAM,IAAI,MAAM,CAAC,yBAAyB,EAAE,UAAU,CAAC;IAE3D;IACA,OAAO;AACT;IAEA,2CAAe;;;AVZf,MAAM,sCACJ,CAAA,SACA,OAAO,YAAY,SAAS,CAAC,CAAC;QAC5B,MAAM,eAAE,WAAW,aAAE,SAAS,EAAE,GAAG;QACnC,MAAM,YAAY,SAAS,CAAC,WAAW;QAEvC,IAAI,CAAC,WAAW,MAAM,IAAI,MAAM,CAAC,SAAS,EAAE,WAAW,gCAAgC,CAAC;QAExF,IAAI;QACJ,IAAI,CAAC,OAAO,MAAM,EAAE,YAAY,UAAU,IAAI,EAAE,YAAY;YAC1D,IAAI,MAAM,OAAO,CAAC,UAAU,IAAI,EAAE,aAChC,MAAM,IAAI,MACR,CAAC,gCAAgC,EAAE,WAAW,iEAAiE,CAAC;YAEpH,6CAA6C;YAC7C,aAAa,CAAA,GAAA,wCAAsB,EAAE,UAAU,IAAI,CAAC,UAAU,EAAE;QAClE,OACE,kGAAkG;QAClG,aAAa,CAAA,GAAA,wCAAsB,EACjC,UAAU,KAAK,EACf,OAAO,MAAM,EAAE,YAAY,UAAU,IAAI,EAAE,SAC3C;QAIJ,IAAI,UAAU,IAAI,EAAE,gBAClB,OAAO,CAAA,GAAA,wCAAc,EAAE,YAAY,QAAQ;QAE7C,OAAO,CAAA,GAAA,wCAAmB,EAAE,YAAY,YAAY,QAAQ;IAC9D;IAEF,2CAAe;;;;AWlCf,MAAM,sCAAgB,CAAA,SAAU,OAAO,YAAY;QACjD,MAAM,yBAAE,qBAAqB,EAAE,GAAG;QAElC,IAAI,aAAa,MAAM,QAAQ,GAAG,CAChC,OAAO,GAAG,CAAC,GAAG,CAAC,CAAA,KACb,CAAA,GAAA,wCAAK,EAAE,QAAQ,YAAY;gBAAE,IAAI,OAAO,OAAO,WAAW,EAAE,CAAC,MAAM,GAAG;YAAG,GACtE,IAAI,CAAC,CAAC,QAAE,IAAI,EAAE,GAAK,MACnB,KAAK,CAAC;gBACL,sCAAsC;gBACtC,8DAA8D;gBAC9D,0DAA0D;gBAC1D,IAAI,uBACF,OAAO;wBAAE;oBAAI,QAAQ;gBAAK;YAE5B,oBAAoB;YACtB;QAIN,6FAA6F;QAC7F,aAAa,WAAW,MAAM,CAAC,CAAA,IAAK;QAEpC,OAAO;YAAE,MAAM;QAAW;IAC5B;IAEA,2CAAe;;;;ACzBf,MAAM,+CAAyB,CAAA,SAAU,OAAO,YAAY;QAC1D,OAAO,MAAM,GAAG;YAAE,GAAG,OAAO,MAAM;YAAE,CAAC,OAAO,MAAM,CAAC,EAAE,OAAO,EAAE;QAAC;QAC/D,OAAO,OAAO,MAAM;QACpB,OAAO,MAAM,CAAA,GAAA,wCAAM,EAAE,QAAQ,YAAY;IAC3C;IAEA,2CAAe;;;;;ACJf,MAAM,kCAAY,IAAI,CAAA,GAAA,yBAAc;AAEpC,MAAM,oCAAc,CAAC,SAA0B,OAAO,YAAoB;QACxE,MAAM,cAAE,UAAU,EAAE,GAAG;QAEvB,MAAM,eAAe;YACnB,MAAM;YACN,UAAU,CAAC;YACX,SAAS,EAAE;QACb;QAEA,IAAI,OAAO,YAAY,EACrB,aAAa,OAAO,CAAC,IAAI,CAAC;YACxB,YAAY;YACZ,QAAQ;gBAAC;oBAAE,MAAM;oBAAO,SAAS,OAAO,YAAY;gBAAC;aAAE;QACzD;QAGF,IAAI,OAAO,eAAe,EACxB,aAAa,OAAO,CAAC,IAAI,CAAC;YACxB,YAAY;YACZ,QAAQ;gBAAC;oBAAE,MAAM;oBAAO,SAAS,OAAO,eAAe;gBAAC;aAAE;QAC5D;QAGF,MAAM,WAAW,CAAC,EAAE,OAAO,EAAE,CAAC,CAAC,EAAE;YAC/B,QAAQ;YACR,SAAS,IAAI,QAAQ;gBACnB,gBAAgB;YAClB;YACA,MAAM,gCAAU,SAAS,CAAC;QAC5B;IACF;IAEA,2CAAe;;;;AClCf,MAAM,qCAAe,CAAC,SAA0B,OAAO,YAAoB;QACzE,MAAM,cAAE,UAAU,eAAE,WAAW,EAAE,GAAG;QAEpC,iCAAiC;QACjC,MAAM,iBAAE,aAAa,iBAAE,aAAa,EAAE,GAAG,MAAM,CAAA,GAAA,wCAAU,EAAE,MAAM,CAAC,OAAO,IAAI,EAAE;QAC/E,OAAO,IAAI,GAAG;QAEd,MAAM,WAAW,CAAC,EAAE,OAAO,EAAE,CAAC,CAAC,EAAE;YAC/B,QAAQ;YACR,MAAM,KAAK,SAAS,CAAC;gBACnB,YAAY;gBACZ,GAAG,OAAO,IAAI;YAChB;QACF;QAEA,4CAA4C;QAC5C,MAAM,CAAA,GAAA,wCAAU,EAAE,MAAM,CAAC,eAAe;QAExC,OAAO;YAAE,MAAM,OAAO,IAAI;QAAC;IAC7B;IAEA,2CAAe;;;;;;ACrBf,MAAM,wCAAkB,OAAM;IAC5B,MAAM,eAAE,WAAW,cAAE,UAAU,EAAE,GAAG;IACpC,MAAM,QAAQ,aAAa,OAAO,CAAC;IACnC,MAAM,SAAS,CAAA,GAAA,wCAAmB,EAAE,OAAO;IAC3C,MAAM,gBAAgB,CAAA,GAAA,wCAAmB,EAAE,cAAc;IAEzD,2BAA2B;IAC3B,IAAI,OAAO;QACT,MAAM,UAAU,CAAA,GAAA,0CAAQ,EAAE;QAC1B,MAAM,QAAQ,QAAQ,KAAK,IAAI,QAAQ,KAAK,EAAE,2CAA2C;QACzF,IAAI;QAEJ,IAAI;YACF,MAAM,QAAE,IAAI,EAAE,GAAG,MAAM,WAAW;YAClC,WAAW;QACb,EAAE,OAAO,GAAG;YACV,QAAQ,KAAK,CAAC;YACd,kFAAkF;YAClF,aAAa,KAAK;YAClB,OAAO,QAAQ,CAAC,MAAM;YACtB;QACF;QAEA,0BAA0B;QAC1B,IAAI,QAAQ;YACV,gDAAgD;YAChD,4CAA4C;YAC5C,OAAO,WAAW,CAAC,OAAO,CAAC,IAAI,GAAG;YAClC,OAAO,WAAW,CAAC,OAAO,CAAC,OAAO,GAAG,CAAA,GAAA,wCAAM,EAAE,OAAO,SAAS,sCAAsC;YACnG,OAAO,WAAW,CAAC,OAAO,CAAC,cAAc,GACvC,SAAS,SAAS,EAAE,CAAC,sBAAsB,IAAI,CAAA,GAAA,wCAAM,EAAE,OAAO;QAClE;QAEA,IAAI,eACF,gDAAgD;QAChD,4CAA4C;QAC5C,OAAO,WAAW,CAAC,cAAc,CAAC,QAAQ,GAAG,SAAS,SAAS,EAAE;IAErE,OAAO,IAAI,QACT,sDAAsD;IACtD,OAAO,OAAO,WAAW,CAAC,OAAO;AAErC;IAEA,2CAAe;;;AChDf,MAAM,uCAAiB,CAAA,QAAU,CAAC,QAAQ,YAAY,MAAM,OAAO,CAAC,SAAS,QAAQ;QAAC;KAAM;AAE5F,MAAM,2CAAqB,OAAM;IAC/B,MAAM,gBAAgB,OAAO,OAAO,CAAC,OAAO,WAAW,EACpD,MAAM,CAAC,CAAC,CAAC,KAAK,OAAO,GAAK,OAAO,GAAG,KAAK,QAAQ,OAAO,IAAI,KAAK,OACjE,GAAG,CAAC,CAAC,CAAC,KAAK,OAAO,GACjB,OACG,UAAU,CAAC,IAAI,IAAI,qBAAqB,OAAO,OAAO,EAAE,QAAQ,IAChE,IAAI,CAAC,CAAA,SAAW,CAAA;qBAAE;gBAAK,UAAU,OAAO,IAAI,CAAC,SAAS;YAAC,CAAA,GACvD,KAAK,CAAC,CAAA;YACL,IAAI,EAAE,MAAM,KAAK,OAAO,EAAE,MAAM,KAAK,OAAO,EAAE,MAAM,KAAK,KACvD,OAAO;qBAAE;gBAAK,OAAO;YAAE;YAEzB,MAAM;QACR;IAGN,IAAI,UAAU,EAAE;IAEhB,IAAI;QACF,UAAU,MAAM,QAAQ,GAAG,CAAC;IAC9B,EAAE,OAAO,GAAG;IACV,0CAA0C;IAC5C;IAEA,KAAK,MAAM,UAAU,QAAS;QAC5B,OAAO,WAAW,CAAC,OAAO,GAAG,CAAC,CAAC,UAAU,GAAG,OAAO,WAAW,CAAC,OAAO,GAAG,CAAC,CAAC,UAAU,IAAI,CAAC;QAC1F,OAAO,WAAW,CAAC,OAAO,GAAG,CAAC,CAAC,UAAU,GAAG,OAAO,WAAW,CAAC,OAAO,GAAG,CAAC,CAAC,UAAU,IAAI,CAAC;QAE1F,+BAA+B;QAC/B,IAAI,OAAO,QAAQ,EACjB,KAAK,MAAM,WAAW,OAAO,QAAQ,CAAE;YACrC,MAAM,mBAAmB,OAAO,IAAI,CAAC,OAAO,WAAW,EAAE,IAAI,CAC3D,CAAA,MAAO,OAAO,CAAC,gBAAgB,KAAK,OAAO,WAAW,CAAC,IAAI,CAAC,OAAO;YAGrE,8EAA8E;YAC9E,IAAI,kBAAkB;gBACpB,yDAAyD;gBACzD,IAAI,qBAAqB,OAAO,GAAG,EAAE;oBACnC,OAAO,WAAW,CAAC,OAAO,GAAG,CAAC,CAAC,IAAI,GAAG,OAAO,WAAW,CAAC,OAAO,GAAG,CAAC,CAAC,IAAI,IAAI,OAAO,CAAC,WAAW;oBAChG,OAAO,WAAW,CAAC,OAAO,GAAG,CAAC,CAAC,WAAW,GACxC,OAAO,WAAW,CAAC,OAAO,GAAG,CAAC,CAAC,WAAW,IAAI,OAAO,CAAC,iBAAiB;oBACzE,OAAO,WAAW,CAAC,OAAO,GAAG,CAAC,CAAC,cAAc,GAC3C,OAAO,WAAW,CAAC,OAAO,GAAG,CAAC,CAAC,cAAc,IAAI,OAAO,CAAC,sBAAsB;gBACnF;gBAEA,OAAO,WAAW,CAAC,OAAO,GAAG,CAAC,CAAC,UAAU,CAAC,iBAAiB,GACzD,OAAO,WAAW,CAAC,OAAO,GAAG,CAAC,CAAC,UAAU,CAAC,iBAAiB,IAAI,CAAC;gBAElE,KAAK,MAAM,aAAa,qCAAe,OAAO,CAAC,sBAAsB,EACnE,KAAK,MAAM,QAAQ,qCAAe,SAAS,CAAC,aAAa,EAAG;oBAC1D,yBAAyB;oBACzB,MAAM,OAAO,SAAS,CAAC,gBAAgB,CAAC,OAAO,CAAC,OAAO,CAAC,gBAAgB,EAAE;oBAC1E,IAAI,OAAO,WAAW,CAAC,OAAO,GAAG,CAAC,CAAC,UAAU,CAAC,iBAAiB,CAAC,KAAK,EACnE,OAAO,WAAW,CAAC,OAAO,GAAG,CAAC,CAAC,UAAU,CAAC,iBAAiB,CAAC,KAAK,CAAC,IAAI,CAAC;yBAEvE,OAAO,WAAW,CAAC,OAAO,GAAG,CAAC,CAAC,UAAU,CAAC,iBAAiB,CAAC,KAAK,GAAG;wBAAC;qBAAK;gBAE9E;YAEJ;QACF;IAEJ;AACF;IAEA,2CAAe;;;;;AEnEf,oDAAoD;AACpD,MAAM,4CAAsB,CAAC,KAAK;IAChC,IAAI,CAAC,KAAK,MAAM,MAAM,CAAC,sCAAsC,CAAC;IAC9D,OAAO,OAAO,IAAI,CAAC,aAAa,IAAI,CAAC,CAAA;QACnC,IAAI,WAAW,CAAC,IAAI,CAAC,GAAG,EACtB,sHAAsH;QACtH,OAAO,WAAW,CAAC,IAAI,CAAC,OAAO,IAAI,IAAI,UAAU,CAAC,WAAW,CAAC,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,SAAS;QAE9F,OAAO,IAAI,UAAU,CAAC,WAAW,CAAC,IAAI,CAAC,OAAO;IAChD;AACF;IAEA,2CAAe;;;;ADRf;;;CAGC,GACD,MAAM,mCACJ,CAAA,cACA,CAAC,KAAK,UAAU,CAAC,CAAC;QAChB,MAAM,gBAAgB,CAAA,GAAA,wCAAmB,EAAE,cAAc;QACzD,MAAM,YAAY,CAAA,GAAA,wCAAkB,EAAE,KAAK;QAC3C,MAAM,WACJ,cAAc,iBAAiB,WAAW,CAAC,cAAc,EAAE,YAAY,WAAW,CAAC,UAAU,EAAE,YAAY;QAE7G,IAAI,CAAC,QAAQ,OAAO,EAAE,QAAQ,OAAO,GAAG,IAAI;QAE5C,OAAQ,QAAQ,MAAM;YACpB,KAAK;YACL,KAAK;YACL,KAAK;gBACH,IAAI,CAAC,QAAQ,OAAO,CAAC,GAAG,CAAC,WAAW,QAAQ,OAAO,CAAC,GAAG,CAAC,UAAU;gBAClE,IAAI,CAAC,QAAQ,OAAO,CAAC,GAAG,CAAC,iBAAiB,QAAQ,OAAO,CAAC,GAAG,CAAC,gBAAgB;gBAC9E;YAEF,KAAK;gBACH;YAEF,KAAK;YACL;gBACE,IAAI,CAAC,QAAQ,OAAO,CAAC,GAAG,CAAC,WAAW,QAAQ,OAAO,CAAC,GAAG,CAAC,UAAU;gBAClE;QACJ;QAEA,IAAI,UAAU;YACZ,MAAM,WAAW,IAAI;YAErB,SAAS,MAAM,CAAC,MAAM;YACtB,SAAS,MAAM,CAAC,UAAU,QAAQ,MAAM,IAAI;YAC5C,SAAS,MAAM,CAAC,WAAW,KAAK,SAAS,CAAC,OAAO,WAAW,CAAC,QAAQ,OAAO,CAAC,OAAO;YAEpF,IAAI,QAAQ,IAAI;gBACd,IAAI,QAAQ,IAAI,YAAY,MAC1B,SAAS,MAAM,CAAC,QAAQ,QAAQ,IAAI,EAAE,QAAQ,IAAI,CAAC,IAAI;qBAEvD,SAAS,MAAM,CAAC,QAAQ,QAAQ,IAAI;;YAIxC,yDAAyD;YACzD,OAAO,CAAA,GAAA,4BAAS,EAAE,SAAS,CAAC,WAAW,CAAC,cAAc,CAAC,QAAQ,EAAE;gBAC/D,QAAQ;gBACR,SAAS,IAAI,QAAQ;oBACnB,eAAe,CAAC,OAAO,EAAE,aAAa,OAAO,CAAC,SAAS,CAAC;gBAC1D;gBACA,MAAM;YACR;QACF;QACA,yDAAyD;QACzD,IAAI,cAAc,eAAe;YAC/B,MAAM,QAAQ,aAAa,OAAO,CAAC;YACnC,IAAI,OAAO,QAAQ,OAAO,CAAC,GAAG,CAAC,iBAAiB,CAAC,OAAO,EAAE,MAAM,CAAC;QACnE;QACA,OAAO,CAAA,GAAA,4BAAS,EAAE,SAAS,CAAC,KAAK;IACnC;IAEF,2CAAe;;;A7BnDf,MAAM,qCAAe,CAAA;IACnB,qDAAqD;IACrD,IAAI,CAAC,CAAA,GAAA,wCAAmB,EAAE,WAAW,OAAO,WAAW,GACrD,MAAM,IAAI,MAAM;IAElB,IAAI,CAAC,OAAO,WAAW,EAAE,OAAO,WAAW,GAAG,OAAO,WAAW,CAAC,OAAO,UAAU,CAAC,GAAG,CAAC,CAAA,IAAK;YAAC,EAAE,MAAM;YAAE,EAAE,GAAG;SAAC;IAC7G,IAAI,CAAC,OAAO,qBAAqB,EAAE,OAAO,qBAAqB,GAAG;IAElE,0EAA0E;IAC1E,OAAO,UAAU,GAAG,CAAA,GAAA,wCAAS,EAAE,OAAO,WAAW;IAEjD,6BAA6B;IAC7B,MAAM,iBAAiB;QAAE,GAAG,MAAM;IAAC;IAEnC,IAAI,yBAAyB,CAAA,GAAA,wCAAc,EAAE;IAC7C,IAAI,4BAA4B,CAAA,GAAA,wCAAiB,EAAE;IAEnD,MAAM,gBACJ,CAAA,SACA,OAAO,GAAG;YACR,MAAM;YACN,MAAM,2BAA2B,6CAA6C;YAC9E,OAAO,MAAM,UAAU;QACzB;IAEF,OAAO;QACL,SAAS,cAAc,CAAA,GAAA,wCAAY,EAAE;QACrC,SAAS,cAAc,CAAA,GAAA,wCAAY,EAAE;QACrC,kBAAkB,cAAc,CAAA,GAAA,wCAAqB,EAAE;QACvD,QAAQ,cAAc,CAAA,GAAA,wCAAW,EAAE;QACnC,QAAQ,cAAc,CAAA,GAAA,wCAAW,EAAE;QACnC,QAAQ,cAAc,CAAA,GAAA,wCAAW,EAAE;QACnC,YAAY;YACV,MAAM,IAAI,MAAM;QAClB;QACA,QAAQ,cAAc,CAAA,GAAA,wCAAW,EAAE;QACnC,YAAY,cAAc,CAAA,GAAA,wCAAe,EAAE;QAC3C,iBAAiB;QACjB,OAAO,cAAc,CAAA,GAAA,wCAAU,EAAE;QACjC,eAAe,cAAc,CAAA,GAAA,wCAAkB,EAAE;QACjD,gBAAgB,cAAc,CAAA,GAAA,wCAAmB,EAAE;QACnD,qBAAqB,CAAA,GAAA,wCAAmB,EAAE;QAC1C,OAAO,cAAc,OAAO,UAAU;QACtC,eAAe;YACb,SAAS;gBAAE,GAAG,cAAc;YAAC;YAC7B,yBAAyB,CAAA,GAAA,wCAAc,EAAE;YACzC,4BAA4B,CAAA,GAAA,wCAAiB,EAAE;YAC/C,MAAM;YACN,MAAM;YACN,OAAO;QACT;IACF;AACF;IAEA,2CAAe;;;;;;;A+BnEf,MAAM,gCAAU,CAAC,eAAe,SAC9B,OAAO,kBAAkB,aAAa,cAAc,UAAU;AAChE,MAAM,8BAAQ,CAAA,MAAO,OAAO,QAAQ,YAAY,IAAI,UAAU,CAAC;AAE/D,MAAM,2CAAqB,CAAA;IACzB,4GAA4G;IAC5G,MAAM,eAAe,CAAA,GAAA,uBAAS,EAAE,CAAA,GAAA,qCAAkB;IAClD,MAAM,cAAc,aAAa,mBAAmB;IAEpD,MAAM,uBAAuB,CAAA,GAAA,oBAAM,EAAE;QACnC,IAAI,aACF,OAAO,OAAO,WAAW,CACvB,OAAO,MAAM,CAAC,aAAa,GAAG,CAAC,CAAA;YAC7B,iGAAiG;YACjG,MAAM,gBAAgB,OAAO,aAAa,KAAK,YAAY,OAAO,aAAa,GAAG,CAAC,OAAO,OAAO;YACjG,OAAO;gBAAC,OAAO,OAAO;gBAAE;aAAc;QACxC;IAGN,GAAG;QAAC;KAAY;IAEhB,OAAO,CAAA,GAAA,wBAAU,EACf,CAAA;QACE,MAAM,iCAAiC,8BAAQ,wBAAwB;QACvE,0FAA0F;QAC1F,IAAI,mCAAmC,OAAO,OAAO;QAErD,IAAI,CAAC,QAAQ,IAAI,OAAO;QAExB,MAAM,gBAAgB,OAAO,IAAI,CAAC,sBAAsB,IAAI,CAAC,CAAA,UAAW,QAAQ,GAAG,WAAW;QAC9F,8EAA8E;QAC9E,IAAI,CAAC,eAAe,OAAO;QAE3B,MAAM,8BAA8B,8BAAQ,oBAAoB,CAAC,cAAc,EAAE;QACjF,4FAA4F;QAC5F,IAAI,gCAAgC,OAAO,OAAO;QAElD,IAAI,4BAAM,iCACR,OAAO;QAET,IAAI,4BAAM,8BACR,OAAO;QAET,OAAO,OAAO,EAAE;IAClB,GACA;QAAC;QAAsB;KAAuB;AAElD;IAEA,2CAAe;;;;;;AEjDf,MAAM,qCAAe,CAAC;IACpB,qEAAqE;IACrE,MAAM,eAAe,CAAA,GAAA,uBAAS,EAAE,CAAA,GAAA,qCAAkB;IAClD,MAAM,CAAC,WAAW,aAAa,GAAG,CAAA,GAAA,qBAAO,EAAO,YAAY,yBAAyB;IAErF,CAAA,GAAA,sBAAQ,EAAE;QACR,aAAa,aAAa,GAAG,IAAI,CAAC,CAAC,UAAiB,aAAa,OAAO,CAAC,WAAW;IACtF,GAAG;QAAC;QAAc;QAAY;KAAa;IAE3C,OAAO;AACT;IAEA,2CAAe;;;;;ACXf,MAAM,uCAAiB;IACrB,MAAM,eAAe,CAAA,GAAA,iCAAc;IACnC,MAAM,CAAC,aAAa,eAAe,GAAG,CAAA,GAAA,qBAAO;IAE7C,CAAA,GAAA,sBAAQ,EAAE;QACR,aAAa,cAAc,GAAG,IAAI,CAAC,CAAA;YACjC,eAAe;QACjB;IACF,GAAG;QAAC;QAAc;KAAe;IAEjC,OAAO;AACT;IAEA,2CAAe;;;;AFXf,MAAM,sCAAgB,CAAC,YAAoB,aAAa,MAAM;IAC5D,MAAM,YAAY,CAAA,GAAA,wCAAW,EAAE;IAC/B,MAAM,cAAc,CAAA,GAAA,wCAAa;IACjC,MAAM,CAAC,YAAY,cAAc,GAAG,CAAA,GAAA,qBAAO;IAE3C,CAAA,GAAA,sBAAQ,EAAE;QACR,IAAI,aAAa,aACf,cAAc,CAAA,GAAA,wCAAsB,EAAE,UAAU,KAAK,EAAE,YAAY;IAEvE,GAAG;QAAC;QAAW;QAAa;KAAW;IAEvC,OAAO;AACT;IAEA,2CAAe;;;;;;;;AIjBf,MAAM,qDAA+B,CACnC,OACA,iBACA;IAEA,MAAM,aAAuB,EAAE;IAE/B,OAAO,IAAI,CAAC,WAAW,CAAC,gBAAgB,CAAC,UAAU,EAAE,CAAC,gBAAgB,IAAI,CAAC,GAAG,OAAO,CAAC,CAAA;QACpF,IAAI,MAAM,QAAQ,CAAC,OACjB,WAAW,CAAC,gBAAgB,CAAC,UAAU,AAAC,CAAC,gBAAgB,CAAC,KAAK,CAAC,OAAO,CAAC,CAAA;YACtE,MAAM,eAAe,CAAA,GAAA,wCAAM,EAAE,WAAW,CAAC,gBAAgB,CAAC,OAAO,EAAE;YACnE,IAAI,CAAC,WAAW,QAAQ,CAAC,eACvB,WAAW,IAAI,CAAC;QAEpB;IAEJ;IAEA,IAAI,WAAW,MAAM,KAAK,GACxB,MAAM,IAAI,MACR,CAAC,uCAAuC,EAAE,KAAK,SAAS,CACtD,OACA,wEAAwE,CAAC;SAExE,IAAI,WAAW,MAAM,GAAG,GAC7B,MAAM,IAAI,MACR,CAAC,kDAAkD,EAAE,KAAK,SAAS,CACjE,OACA,+EAA+E,CAAC;IAItF,OAAO,UAAU,CAAC,EAAE;AACtB;IAEA,2CAAe;;;;AD/Bf,oDAAoD,GACpD,MAAM,2CAAqB,CAAA;IACzB,MAAM,YAAY,CAAA,GAAA,wCAAW,EAAE;IAC/B,MAAM,cAAc,CAAA,GAAA,wCAAa;IACjC,MAAM,CAAC,iBAAiB,mBAAmB,GAAG,CAAA,GAAA,qBAAO;IAErD,CAAA,GAAA,sBAAQ,EAAE;QACR,IAAI,aAAa,aAAa;YAC5B,IAAI,UAAU,MAAM,EAAE,WAAW;gBAC/B,MAAM,CAAC,WAAW,KAAK,GAAG,OAAO,OAAO,CAAC,UAAU,MAAM,CAAC,SAAS,CAAC,CAAC,EAAE;gBACvE,IAAI,CAAC,aAAa,CAAC,WAAW,CAAC,UAAU,EACvC,MAAM,IAAI,MAAM,CAAC,gEAAgE,EAAE,WAAW,CAAC;gBAEjG,mBAAmB,CAAA,GAAA,wCAAM,EAAE,WAAW,CAAC,UAAU,CAAC,OAAO,EAAE;YAC7D,OAAO,IAAI,UAAU,MAAM,EAAE,QAC3B,mBAAmB,CAAA,GAAA,wCAA2B,EAAE,UAAU,KAAK,EAAE,UAAU,MAAM,EAAE,QAAQ;iBACtF;gBACL,MAAM,mBAAmB,CAAA,GAAA,wCAAmB,EAAE,WAAW;gBACzD,mBAAmB,CAAA,GAAA,wCAA2B,EAAE,UAAU,KAAK,EAAE,kBAAkB;YACrF;QACF;IACF,GAAG;QAAC;QAAW;QAAa;KAAmB;IAE/C,OAAO;AACT;IAEA,2CAAe;;;;;;;;;;AG7Bf,MAAM,sCAAgB;IACpB,MAAM,eAAe,CAAA,GAAA,iCAAc;IACnC,MAAM,CAAC,YAAY,cAAc,GAAG,CAAA,GAAA,qBAAO;IAE3C,CAAA,GAAA,sBAAQ,EAAE;QACR,aAAa,aAAa,GAAG,IAAI,CAAC,CAAA;YAChC,cAAc;QAChB;IACF,GAAG;QAAC;QAAc;KAAc;IAEhC,OAAO;AACT;IAEA,2CAAe;;;ADVf,MAAM,8CAAwB;IAC5B,MAAM,aAAa,CAAA,GAAA,wCAAY;IAC/B,MAAM,cAAc,CAAA,GAAA,wCAAa;IAEjC,MAAM,kBAAkB,CAAA,GAAA,wBAAU,EAChC,CAAC;QACC,IAAI,CAAC,cAAc,CAAC,eAAe,CAAC,UAAU,CAAC,WAAW,EACxD,OAAO;QAGT,MAAM,YAAY,UAAU,CAAC,WAAW;QAExC,IAAI,UAAU,MAAM,EAAE,WAAW;YAC/B,MAAM,CAAC,WAAW,KAAK,GAAG,OAAO,OAAO,CAAC,UAAU,MAAM,CAAC,SAAS,CAAC,CAAC,EAAE;YACvE,IAAI,CAAC,aAAa,CAAC,WAAW,CAAC,UAAU,EACvC,MAAM,IAAI,MAAM,CAAC,gEAAgE,EAAE,WAAW,CAAC;YAEjG,OAAO,CAAA,GAAA,wCAAM,EAAE,WAAW,CAAC,UAAU,CAAC,OAAO,EAAE;QACjD;QAEA,IAAI,UAAU,MAAM,EAAE,QACpB,OAAO,CAAA,GAAA,wCAA2B,EAAE,UAAU,KAAK,EAAE,UAAU,MAAM,EAAE,QAAQ;QAGjF,MAAM,mBAAmB,CAAA,GAAA,wCAAmB,EAAE,WAAW;QAEzD,IAAI,CAAC,kBACH,MAAM,IAAI,MACR,CAAC,+FAA+F,CAAC;QAIrG,OAAO,CAAA,GAAA,wCAA2B,EAAE,UAAU,KAAK,EAAE,kBAAkB;IACzE,GACA;QAAC;QAAY;KAAY;IAG3B,OAAO;AACT;IAEA,2CAAe;;;;;;;;AE7Cf;;;;;;;;;;;;;CAaC,GAED,MAAM,sCAAgB,CAAC,YAAE,QAAQ,UAAE,MAAM,UAAE,MAAM,UAAE,MAAM,EAAE,GAAG,YAAY;IACxE,MAAM,CAAC,UAAU,YAAY,GAAG,CAAA,GAAA,qBAAO;IACvC,CAAA,GAAA,sBAAQ,EAAE;QACR,IAAI,UAAU,UAAU,MAAM,OAAO,CAAC,QAAQ,CAAC,OAAO,GAAG;YACvD,MAAM,eAAe,QAAQ,CAAC,OAAO,CAAC,OAAO,CAAA;gBAC3C,IAAI,KAAK;gBACT,IAAK,MAAM,OAAO,OAAQ;oBACxB,MAAM,QAAQ,CAAC,CAAC,IAAI;oBACpB,IAAI,MAAM,OAAO,CAAC,QAChB;wBAAA,IAAI,CAAC,MAAM,QAAQ,CAAC,MAAM,CAAC,IAAI,GAC7B,KAAK;oBACP,OACK,IAAI,UAAU,MAAM,CAAC,IAAI,EAC9B,KAAK;gBAET;gBACA,OAAO;YACT;YACA,MAAM,YAAY;gBAChB,GAAG,MAAM;YACX;YACA,8EAA8E;YAC9E,SAAS,CAAC,OAAO,GAAG,aAAa,MAAM,GAAG,IAAI,eAAe;YAC7D,YAAY;QACd;IACF,GAAG;QAAC;QAAQ;QAAQ;KAAO;IAE3B,qBACE;kBACG,CAAA,GAAA,sCAAI,EAAE,QAAQ,CAAC,GAAG,CAAC,UAAU,CAAC,OAAO;YACpC,qBAAO,CAAA,GAAA,sCAAI,EAAE,YAAY,CAAC,OAAO;gBAC/B,GAAG,UAAU;gBACb,QAAQ;wBACR;YACF;QACF;;AAGN;IACA,2CAAe;;;;;;;ACpDf;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA4DC,GACD,MAAM,gDAA0B,CAAC,YAC/B,QAAQ,kBACR,cAAc,cACd,UAAU,eACV,WAAW,kBACX,cAAc,EACd,GAAG,YACJ;IACC,MAAM,SAAS,CAAA,GAAA,kCAAe;IAC9B,MAAM,QAAE,IAAI,EAAE,GAAG,CAAA,GAAA,4BAAS,EAAE;IAE5B,qBACE;kBACG,MAAM,IAAI,CAAC,MAAM;YAChB,MAAM,SAAS,CAAC;YAChB,MAAM,CAAC,eAAe,GAAG,KAAK,EAAE;YAChC,qBACE;;oBACG,eAAe,YAAY;wBAAE,GAAG,UAAU;wBAAE,OAAO;oBAAK;kCACzD,gCAAC,CAAA,GAAA,wCAAY;wBAAG,GAAG,UAAU;wBAAE,QAAQ;wBAAQ,QAAQ;wBAAQ,OAAO,IAAI,CAAC,WAAW;kCACnF;;;;QAIT;;AAGN;IAEA,2CAAe;;;;;;;AC1Ff,MAAM,gDAA0B,CAAA,GAAA,oDAAS,EAAE;IACzC,MAAM;QACJ,SAAS;IACX;IACA,OAAO;QACL,cAAc;IAChB;AACF;AAEA,MAAM,2CAAqB,CAAA,GAAA,oDAAS,EAAE;IACpC,MAAM;QACJ,SAAS;IACX;AACF;AAEA,MAAM,8CAAwB,CAAA;IAC5B,MAAM,oBAAE,gBAAgB,YAAE,QAAQ,EAAE,GAAG,YAAY,GAAG;IACtD,MAAM,kBAAkB;IACxB,MAAM,kBAAkB;IAExB,qBACE,gCAAC,CAAA,GAAA,4BAAS;QAAG,GAAG,UAAU;kBACxB,cAAA,iCAAC,CAAA,GAAA,oCAAiB;YAAE,SAAS;gBAAE,MAAM,gBAAgB,IAAI;YAAC;;gBACvD,CAAA,GAAA,sCAAI,EAAE,QAAQ,CAAC,GAAG,CAAC,MAAM,QAAQ,EAAE,CAAC,OAAO;oBAC1C,qBAAO,CAAA,GAAA,sCAAI,EAAE,YAAY,CAAC,OAAO;wBAC/B,WAAW,gBAAgB,KAAK;oBAClC;gBACF;8BACA,gCAAC,CAAA,GAAA,2BAAQ;oBAAE,WAAW,gBAAgB,IAAI;oBAAE,QAAO;oBAAO,cAAc;;;;;AAIhF;IAEA,2CAAe;;;;ACnBf;;CAEC,GACD,MAAM,gDAA0B,OAAO,OAAgB;IACrD,MAAM,WAAE,OAAO,EAAE,GAAG,MAAM,MAAM,aAAa;QAAE,QAAQ;IAAO;IAC9D,MAAM,aAAa,QAAQ,GAAG,CAAC;IAE/B,MAAM,UAAU,YAAY,MAC1B;IAEF,IAAI,CAAC,SAAS,CAAC,EAAE,EACf,OAAO;IAIT,MAAM,EAAE,MAAM,mBAAmB,EAAE,GAAG,MAAM,MAAM,OAAO,CAAC,EAAE;IAC5D,OAAO;AACT;AAEA,MAAM,4CAAiC,OACrC,OACA,aACA,UAAqC;IAAE,MAAM;AAAuB,CAAC;IAErE,MAAM,QAAE,IAAI,cAAE,UAAU,WAAE,OAAO,QAAE,IAAI,EAAE,GAAG;IAC5C,IAAI,WAAE,OAAO,SAAE,KAAK,EAAE,GAAG;IACzB,IAAI,WAAW,CAAC,SAAS,UAAU,IAAI,KAAK,KAAK,GAAG,KAAK,SAAS,WAAW;IAC7E,IAAI,cAAc,CAAC,OAAO,QAAQ,IAAI,KAAK,KAAK,GAAG,KAAK,YAAY,WAAW;IAE/E,MAAM,sBAAsB,MAAM,8CAAwB,OAAO;IAEjE,6DAA6D;IAC7D,kEAAkE;IAClE,MAAM,sBAAsB,AAC1B,CAAA,MAAM,QAAQ,GAAG,CACf,yEAAyE;IACzE,CAAA,GAAA,wCAAM,EAAE,oBAAoB,YAAY,IAAI,mBAAmB,CAAC,sBAAsB,EAAE,GAAG,CACzF,OAAM;QACJ,gCAAgC;QAChC,IAAI,OAAO,6BAA6B,UAAU;YAChD,MAAM,QAAE,IAAI,EAAE,GAAG,MAAM,MAAM;YAC7B,OAAO;QACT;QACA,OAAO;IACT,GAEJ,EACA,IAAI,CAAC,CAAC;QACN,uDAAuD;QACvD,MAAM,cAAc,QAAQ,WAAW,IAAI,OAAO,CAAC,qBAAqB;QACxE,OAAO,gBAAgB,QAAQ,gBAAgB,CAAC,OAAO,EAAE,KAAK,CAAC;IACjE;IAEA,IAAI,CAAC,qBACH,MAAM,IAAI,MAAM,CAAC,0DAA0D,EAAE,KAAK,CAAC;IAGrF,wBAAwB;IACxB,MAAM,EAAE,MAAM,OAAO,EAAE,GAAG,MAAM,MAAM,oBAAoB,EAAE,IAAI,mBAAmB,CAAC,MAAM,EAAE;QAC1F,QAAQ;QACR,MAAM,KAAK,SAAS,CAAC;YACnB,YAAY;YACZ,MAAM;YACN,OAAO;qBACP;mBACA;kBACA;QACF;IACF;IAEA,OAAO;AACT;AAEA,MAAM,4CAAkB,OAAO,OAAgB,aAAqB;IAClE,MAAM,UAAU,MAAM,0CAA+B,OAAO,aAAa;IACzE,MAAM,cAAsB,QAAQ,WAAW,IAAI,OAAO,CAAC,qBAAqB;IAEhF,OAAO,IAAI,UAAU;AACvB;AAEA,MAAM,6CAAuB,IAAI;AAEjC;;;;;CAKC,GACD,MAAM,4CAAuB,OAC3B,OACA,aACA,UAAqC;IAAE,MAAM;IAAwB,YAAY;AAAe,CAAC;IAEjG,MAAM,SAAS,2CAAqB,GAAG,CAAC;IACxC,IAAI,QACF,uCAAuC;IACvC,OAAO;IAGT,qEAAqE;IACrE,iEAAiE;IACjE,MAAM,YAAY,0CAAgB,OAAO,aAAa;QAAE,GAAG,OAAO;QAAE,MAAM;IAAuB,GAAG,IAAI,CAAC,CAAA;QACvG,mDAAmD;QACnD,GAAG,gBAAgB,CAAC,SAAS,CAAA;YAC3B,2CAAqB,MAAM,CAAC;QAC9B;QACA,+DAA+D;QAC/D,MAAM,UAAU,QAAQ,UAAU,IAAK,CAAA,QAAQ,KAAK,IAAI,IAAI,KAAK,QAAQ,KAAK,EAAE,OAAO,KAAK,KAAK,GAAG,EAAC;QACrG,IAAI,SACF,WAAW;YACT,GAAG,KAAK;QACV,GAAG;QAEL,OAAO;IACT;IAEA,2CAAqB,GAAG,CAAC,aAAa;IACtC,OAAO;AACT;;;;ACzIA,oEAAoE,GACpE;","sources":["packages/semantic-data-provider/src/index.ts","packages/semantic-data-provider/src/dataProvider/dataProvider.js","packages/semantic-data-provider/src/dataProvider/methods/create.js","packages/semantic-data-provider/src/dataProvider/methods/getOne.js","packages/semantic-data-provider/src/dataProvider/utils/fetchResource.js","packages/semantic-data-provider/src/dataProvider/utils/handleFiles.ts","packages/semantic-data-provider/src/dataProvider/utils/findContainersWithTypes.ts","packages/semantic-data-provider/src/dataProvider/utils/parseServerKeys.js","packages/semantic-data-provider/src/dataProvider/utils/getServerKeyFromType.js","packages/semantic-data-provider/src/dataProvider/methods/delete.ts","packages/semantic-data-provider/src/dataProvider/methods/deleteMany.js","packages/semantic-data-provider/src/dataProvider/methods/getDataServers.js","packages/semantic-data-provider/src/dataProvider/methods/getDataModels.js","packages/semantic-data-provider/src/dataProvider/methods/getList.js","packages/semantic-data-provider/src/dataProvider/utils/fetchContainers.ts","packages/semantic-data-provider/src/dataProvider/utils/arrayOf.ts","packages/semantic-data-provider/src/dataProvider/utils/fetchSparqlEndpoints.js","packages/semantic-data-provider/src/dataProvider/utils/getEmbedFrame.js","packages/semantic-data-provider/src/dataProvider/utils/buildSparqlQuery.js","packages/semantic-data-provider/src/dataProvider/utils/buildBaseQuery.js","packages/semantic-data-provider/src/dataProvider/utils/resolvePrefix.js","packages/semantic-data-provider/src/dataProvider/utils/buildBlankNodesQuery.js","packages/semantic-data-provider/src/dataProvider/utils/buildAutoDetectBlankNodesQuery.js","packages/semantic-data-provider/src/dataProvider/utils/findContainersWithPath.js","packages/semantic-data-provider/src/dataProvider/methods/getMany.js","packages/semantic-data-provider/src/dataProvider/methods/getManyReference.js","packages/semantic-data-provider/src/dataProvider/methods/patch.ts","packages/semantic-data-provider/src/dataProvider/methods/update.ts","packages/semantic-data-provider/src/dataProvider/utils/fetchUserConfig.js","packages/semantic-data-provider/src/dataProvider/utils/fetchVoidEndpoints.js","packages/semantic-data-provider/src/dataProvider/httpClient.js","packages/semantic-data-provider/src/dataProvider/utils/getServerKeyFromUri.js","packages/semantic-data-provider/src/hooks/useGetExternalLink.js","packages/semantic-data-provider/src/hooks/useContainers.ts","packages/semantic-data-provider/src/hooks/useDataModel.ts","packages/semantic-data-provider/src/hooks/useDataServers.ts","packages/semantic-data-provider/src/hooks/useCreateContainer.js","packages/semantic-data-provider/src/dataProvider/utils/findCreateContainerWithTypes.ts","packages/semantic-data-provider/src/hooks/useCreateContainerUri.ts","packages/semantic-data-provider/src/hooks/useDataModels.ts","packages/semantic-data-provider/src/reification/FilterHandler.js","packages/semantic-data-provider/src/reification/GroupedReferenceHandler.js","packages/semantic-data-provider/src/reification/ReificationArrayInput.js","packages/semantic-data-provider/src/notificationChannels/subscribeToUpdates.ts","packages/semantic-data-provider/src/dataProvider/types.ts"],"sourcesContent":["export { default as dataProvider } from './dataProvider/dataProvider';\n\nexport { default as buildSparqlQuery } from './dataProvider/utils/buildSparqlQuery';\nexport { default as buildBlankNodesQuery } from './dataProvider/utils/buildBlankNodesQuery';\n\nexport { default as useGetExternalLink } from './hooks/useGetExternalLink';\nexport { default as useContainers } from './hooks/useContainers';\nexport { default as useCreateContainer } from './hooks/useCreateContainer';\nexport { default as useCreateContainerUri } from './hooks/useCreateContainerUri';\nexport { default as useDataModel } from './hooks/useDataModel';\nexport { default as useDataModels } from './hooks/useDataModels';\nexport { default as useDataServers } from './hooks/useDataServers';\n\nexport { default as FilterHandler } from './reification/FilterHandler';\nexport { default as GroupedReferenceHandler } from './reification/GroupedReferenceHandler';\nexport { default as ReificationArrayInput } from './reification/ReificationArrayInput';\n\nexport {\n  createWsChannel,\n  getOrCreateWsChannel,\n  createSolidNotificationChannel\n} from './notificationChannels/subscribeToUpdates';\n\nexport * from './dataProvider/types';\n","import createMethod from './methods/create';\nimport deleteMethod from './methods/delete';\nimport deleteManyMethod from './methods/deleteMany';\nimport getDataServersMethod from './methods/getDataServers';\nimport getDataModelsMethod from './methods/getDataModels';\nimport getListMethod from './methods/getList';\nimport getManyMethod from './methods/getMany';\nimport getManyReferenceMethod from './methods/getManyReference';\nimport getOneMethod from './methods/getOne';\nimport patchMethod from './methods/patch';\nimport updateMethod from './methods/update';\nimport fetchUserConfig from './utils/fetchUserConfig';\nimport fetchVoidEndpoints from './utils/fetchVoidEndpoints';\nimport getServerKeyFromType from './utils/getServerKeyFromType';\nimport httpClient from './httpClient';\n\nconst dataProvider = config => {\n  // TODO verify all data provider config + data models\n  if (!getServerKeyFromType('default', config.dataServers))\n    throw new Error('You must define a default server in your dataServers config');\n\n  if (!config.jsonContext) config.jsonContext = Object.fromEntries(config.ontologies.map(o => [o.prefix, o.url]));\n  if (!config.returnFailedResources) config.returnFailedResources = false;\n\n  // Configure httpClient with data servers (this is needed for proxy calls)\n  config.httpClient = httpClient(config.dataServers);\n\n  // Keep in memory for refresh\n  const originalConfig = { ...config };\n\n  let fetchUserConfigPromise = fetchUserConfig(config);\n  let fetchVoidEndpointsPromise = fetchVoidEndpoints(config);\n\n  const waitForConfig =\n    method =>\n    async (...arg) => {\n      await fetchUserConfigPromise;\n      await fetchVoidEndpointsPromise; // Return immediately if promise is fulfilled\n      return await method(...arg);\n    };\n\n  return {\n    getList: waitForConfig(getListMethod(config)),\n    getMany: waitForConfig(getManyMethod(config)),\n    getManyReference: waitForConfig(getManyReferenceMethod(config)),\n    getOne: waitForConfig(getOneMethod(config)),\n    create: waitForConfig(createMethod(config)),\n    update: waitForConfig(updateMethod(config)),\n    updateMany: () => {\n      throw new Error('updateMany is not implemented yet');\n    },\n    delete: waitForConfig(deleteMethod(config)),\n    deleteMany: waitForConfig(deleteManyMethod(config)),\n    // Custom methods\n    patch: waitForConfig(patchMethod(config)),\n    getDataModels: waitForConfig(getDataModelsMethod(config)),\n    getDataServers: waitForConfig(getDataServersMethod(config)),\n    getLocalDataServers: getDataServersMethod(config),\n    fetch: waitForConfig(config.httpClient),\n    refreshConfig: async () => {\n      config = { ...originalConfig };\n      fetchUserConfigPromise = fetchUserConfig(config);\n      fetchVoidEndpointsPromise = fetchVoidEndpoints(config);\n      await fetchUserConfigPromise;\n      await fetchVoidEndpointsPromise;\n      return config;\n    }\n  };\n};\n\nexport default dataProvider;\n","import urlJoin from 'url-join';\nimport getOne from './getOne';\nimport handleFiles from '../utils/handleFiles';\nimport findContainersWithTypes from '../utils/findContainersWithTypes';\n\nconst createMethod = config => async (resourceId, params) => {\n  const { dataServers, resources, httpClient, jsonContext } = config;\n  const dataModel = resources[resourceId];\n\n  if (!dataModel) Error(`Resource ${resourceId} is not mapped in resources file`);\n\n  const headers = new Headers();\n\n  let containerUri;\n  let serverKey;\n  if (dataModel.create?.container) {\n    serverKey = Object.keys(dataModel.create.container)[0];\n    containerUri = urlJoin(dataServers[serverKey].baseUrl, Object.values(dataModel.create.container)[0]);\n  } else {\n    serverKey = dataModel.create?.server || Object.keys(dataServers).find(key => dataServers[key].default === true);\n    if (!serverKey) throw new Error('You must define a server for the creation, or a container, or a default server');\n\n    const containers = findContainersWithTypes(dataModel.types, [serverKey], dataServers);\n    // Extract the containerUri from the results (and ensure there is only one)\n    const serverKeys = Object.keys(containers);\n\n    if (!serverKeys || serverKeys.length === 0)\n      throw new Error(`No container with types ${JSON.stringify(dataModel.types)} found on server ${serverKey}`);\n    if (serverKeys.length > 1 || containers[serverKeys[0]].length > 1)\n      throw new Error(\n        `More than one container detected with types ${JSON.stringify(dataModel.types)} on server ${serverKey}`\n      );\n    containerUri = containers[serverKeys[0]][0];\n  }\n\n  if (params.data) {\n    if (dataModel.fieldsMapping?.title) {\n      if (Array.isArray(dataModel.fieldsMapping.title)) {\n        headers.set('Slug', dataModel.fieldsMapping.title.map(f => params.data[f]).join(' '));\n      } else {\n        headers.set('Slug', params.data[dataModel.fieldsMapping.title]);\n      }\n    }\n\n    // Upload files, if there are any\n    const { updatedRecord } = await handleFiles.upload(params.data, config);\n    params.data = updatedRecord;\n\n    const { headers: responseHeaders } = await httpClient(containerUri, {\n      method: 'POST',\n      headers,\n      body: JSON.stringify({\n        '@context': jsonContext,\n        '@type': dataModel.types,\n        ...params.data\n      })\n    });\n\n    // Retrieve newly-created resource\n    const resourceUri = responseHeaders.get('Location');\n    return await getOne(config)(resourceId, { id: resourceUri });\n  }\n  if (params.id) {\n    headers.set('Content-Type', 'application/sparql-update');\n\n    await httpClient(containerUri, {\n      method: 'PATCH',\n      headers,\n      body: `\n        PREFIX ldp: <http://www.w3.org/ns/ldp#>\n        INSERT DATA { <${containerUri}> ldp:contains <${params.id}>. };\n      `\n    });\n\n    // Create must return the new data, so get them from the remote URI\n    return await getOne(config)(resourceId, { id: params.id });\n  }\n};\n\nexport default createMethod;\n","import fetchResource from '../utils/fetchResource';\n\nconst getOneMethod = config => async (resourceId, params) => {\n  const { resources } = config;\n  const dataModel = resources[resourceId];\n\n  if (!dataModel) throw new Error(`Resource ${resourceId} is not mapped in resources file`);\n\n  const data = await fetchResource(params.id, config);\n\n  // Transform single value into array if forceArray is set\n  if (dataModel.list?.forceArray) {\n    for (const forceArrayItem of dataModel.list?.forceArray || []) {\n      if (data[forceArrayItem] && !Array.isArray(data[forceArrayItem])) {\n        data[forceArrayItem] = [data[forceArrayItem]];\n      }\n    }\n  }\n\n  // TODO activate defaultFetchPlan option\n  // if (dataModel.list?.defaultFetchPlan) {\n  //   for (const node of dataModel.list?.defaultFetchPlan) {\n  //     if (\n  //       data[node] &&\n  //       typeof data[node] === 'string' &&\n  //       data[node].startsWith('http')\n  //     ) {\n  //       try {\n  //         const dataToEmbed = await fetchResource(data[node], config);\n  //         delete dataToEmbed['@context'];\n  //         data[node] = dataToEmbed;\n  //       } catch (e) {\n  //         // Ignore errors (this may happen if user does not have rights to see the resource)\n  //       }\n  //     }\n  //   }\n  // }\n\n  return { data };\n};\n\nexport default getOneMethod;\n","import jsonld from 'jsonld';\n\nconst fetchResource = async (resourceUri, config) => {\n  const { httpClient, jsonContext } = config;\n\n  let { json: data } = await httpClient(resourceUri);\n\n  if (!data) throw new Error(`Not a valid JSON: ${resourceUri}`);\n\n  data.id = data.id || data['@id'];\n\n  // We compact only if the context is different between the frontend and the middleware\n  // TODO deep compare if the context is an object\n  if (data['@context'] !== jsonContext) {\n    data = await jsonld.compact(data, jsonContext);\n  }\n\n  return data;\n};\n\nexport default fetchResource;\n","import urlJoin from 'url-join';\nimport { RaRecord } from 'react-admin';\nimport { Configuration } from '../types';\n\nconst isFile = (o: any): o is { rawFile: File } => o?.rawFile && o.rawFile instanceof File;\nconst isFileToDelete = (o: any): o is { fileToDelete: string } =>\n  o?.fileToDelete !== undefined && o?.fileToDelete !== null;\n\nconst getUploadsContainerUri = (config: Configuration) => {\n  const serverKey = Object.keys(config.dataServers).find(key => config.dataServers[key].uploadsContainer);\n  if (serverKey && config.dataServers[serverKey].uploadsContainer) {\n    return urlJoin(config.dataServers[serverKey].baseUrl, config.dataServers[serverKey].uploadsContainer!);\n  }\n  return null;\n};\n\nconst uploadFile = async (rawFile: File, config: Configuration) => {\n  const uploadsContainerUri = getUploadsContainerUri(config);\n  if (!uploadsContainerUri) throw new Error(\"You must define an uploadsContainer in one of the server's configuration\");\n\n  const response = await config.httpClient(uploadsContainerUri, {\n    method: 'POST',\n    body: rawFile,\n    headers: new Headers({\n      'Content-Type': rawFile.type\n    })\n  });\n\n  if (response.status === 201) {\n    return response.headers.get('Location');\n  }\n  return null;\n};\n\nconst deleteFiles = async (filesToDelete: string[], config: Configuration) => {\n  return Promise.all(\n    filesToDelete.map(file =>\n      config.httpClient(file, {\n        method: 'DELETE'\n      })\n    )\n  );\n};\n\n/*\n * Look for raw files in the record data.\n * If there are any, upload them and replace the file by its URL.\n */\nconst uploadAllFiles = async (record: Partial<RaRecord>, config: Configuration) => {\n  const filesToDelete: string[] = [];\n  const updatedRecord = { ...record };\n\n  for (const property of Object.keys(record)) {\n    const value = record[property];\n    if (Array.isArray(value)) {\n      for (let i = 0; i < value.length; i++) {\n        const itemValue = value[i];\n        if (isFile(itemValue)) {\n          if (isFileToDelete(itemValue)) {\n            filesToDelete.push(itemValue.fileToDelete);\n          }\n          updatedRecord[property][i] = await uploadFile(itemValue.rawFile, config);\n        } else if (isFileToDelete(itemValue)) {\n          filesToDelete.push(itemValue.fileToDelete);\n          updatedRecord[property][i] = null;\n        }\n      }\n    } else if (isFile(value)) {\n      if (isFileToDelete(value)) {\n        filesToDelete.push(value.fileToDelete);\n      }\n      updatedRecord[property] = await uploadFile(value.rawFile, config);\n    } else if (isFileToDelete(value)) {\n      filesToDelete.push(value.fileToDelete);\n      updatedRecord[property] = null;\n    }\n  }\n\n  return {\n    updatedRecord,\n    filesToDelete\n  };\n};\n\nexport default {\n  upload: uploadAllFiles,\n  delete: deleteFiles\n};\n","import urlJoin from 'url-join';\nimport { Configuration, DataServerKey } from '../types';\nimport parseServerKeys from './parseServerKeys';\n\nconst findContainersWithTypes = (\n  types: string[],\n  serverKeys: string | string[] | undefined,\n  dataServers: Configuration['dataServers']\n) => {\n  const containers = {} as Record<DataServerKey, string[]>;\n  const existingContainers: string[] = [];\n\n  const parsedServerKeys = parseServerKeys(serverKeys, dataServers);\n\n  Object.keys(dataServers)\n    .filter(dataServerKey => dataServers[dataServerKey].containers)\n    .forEach(dataServerKey => {\n      Object.keys(dataServers[dataServerKey].containers || {}).forEach(containerKey => {\n        if (!parsedServerKeys || parsedServerKeys.includes(containerKey)) {\n          Object.keys(dataServers[dataServerKey].containers![containerKey]).forEach(type => {\n            if (types.includes(type)) {\n              dataServers[dataServerKey].containers![containerKey][type].map(path => {\n                const containerUri = urlJoin(dataServers[containerKey].baseUrl, path);\n\n                // Avoid returning the same container several times\n                if (!existingContainers.includes(containerUri)) {\n                  existingContainers.push(containerUri);\n\n                  if (!containers[dataServerKey]) containers[dataServerKey] = [];\n                  containers[dataServerKey].push(containerUri);\n                }\n              });\n            }\n          });\n        }\n      });\n    });\n  return containers;\n};\n\nexport default findContainersWithTypes;\n","import getServerKeyFromType from './getServerKeyFromType';\n\nconst parseServerKey = (serverKey, dataServers) => {\n  switch (serverKey) {\n    case '@default':\n      return getServerKeyFromType('default', dataServers);\n    case '@pod':\n      return getServerKeyFromType('pod', dataServers);\n    case '@authServer':\n      return getServerKeyFromType('authServer', dataServers);\n    default:\n      return serverKey;\n  }\n};\n\n// Return the list of servers keys in an array\n// parsing keywords like @all, @default, @pod and @authServer\nconst parseServerKeys = (serverKeys, dataServers) => {\n  if (Array.isArray(serverKeys)) {\n    if (serverKeys.includes('@all')) {\n      return Object.keys(dataServers);\n    }\n    return serverKeys.map(serverKey => parseServerKey(serverKey, dataServers));\n  }\n  if (typeof serverKeys === 'string') {\n    if (serverKeys === '@all') {\n      return Object.keys(dataServers);\n    }\n    if (serverKeys === '@remote') {\n      const defaultServerKey = getServerKeyFromType('default', dataServers);\n      return Object.keys(dataServers).filter(serverKey => serverKey !== defaultServerKey);\n    }\n    return [parseServerKey(serverKeys, dataServers)];\n  }\n  // If server key is empty\n  return false;\n};\n\nexport default parseServerKeys;\n","const getServerKeyFromType = (type, dataServers) => {\n  return Object.keys(dataServers).find(key => {\n    return dataServers[key][type];\n  });\n};\n\nexport default getServerKeyFromType;\n","import { DeleteParams, RaRecord } from 'react-admin';\nimport { Configuration } from '../types';\nimport handleFiles from '../utils/handleFiles';\n\nconst deleteMethod = (config: Configuration) => async (resourceId: string, params: DeleteParams<RaRecord>) => {\n  const { httpClient } = config;\n\n  await httpClient(`${params.id}`, {\n    method: 'DELETE'\n  });\n\n  if (params.meta?.filesToDelete) {\n    await handleFiles.delete(params.meta.filesToDelete, config);\n  }\n\n  return { data: { id: params.id } };\n};\n\nexport default deleteMethod;\n","const deleteManyMethod = config => async (resourceId, params) => {\n  const { httpClient } = config;\n  const ids = [];\n\n  for (const id of params.ids) {\n    try {\n      await httpClient(id, {\n        method: 'DELETE'\n      });\n      ids.push(id);\n    } catch (e) {\n      // Do nothing if we fail to delete a resource\n    }\n  }\n\n  return { data: ids };\n};\n\nexport default deleteManyMethod;\n","const getDataServers = config => () => {\n  return config.dataServers;\n};\n\nexport default getDataServers;\n","const getDataModels = config => () => {\n  return config.resources;\n};\n\nexport default getDataModels;\n","import findContainersWithTypes from '../utils/findContainersWithTypes';\nimport fetchContainers from '../utils/fetchContainers';\nimport fetchSparqlEndpoints from '../utils/fetchSparqlEndpoints';\nimport findContainersWithPaths from '../utils/findContainersWithPath';\n\nconst getListMethod =\n  config =>\n  async (resourceId, params = {}) => {\n    const { dataServers, resources } = config;\n    const dataModel = resources[resourceId];\n\n    if (!dataModel) throw new Error(`Resource ${resourceId} is not mapped in resources file`);\n\n    let containers;\n    if (!params.filter?._servers && dataModel.list?.containers) {\n      if (Array.isArray(dataModel.list?.containers))\n        throw new Error(\n          `The list.containers property of ${resourceId} dataModel must be of type object ({ serverKey: [containerUri] })`\n        );\n      // If containers are set explicitly, use them\n      containers = findContainersWithPaths(dataModel.list.containers, dataServers);\n    } else {\n      // Otherwise find the container URIs on the given servers (either in the filter or the data model)\n      containers = findContainersWithTypes(\n        dataModel.types,\n        params.filter?._servers || dataModel.list?.servers,\n        dataServers\n      );\n    }\n\n    if (dataModel.list?.fetchContainer) {\n      return fetchContainers(containers, params, config);\n    }\n    return fetchSparqlEndpoints(containers, resourceId, params, config);\n  };\n\nexport default getListMethod;\n","import jsonld, { ContextDefinition } from 'jsonld';\nimport { GetListParams } from 'react-admin';\nimport arrayOf from './arrayOf';\nimport { Configuration, ContainerURI, DataServerKey } from '../types';\n\ntype LDPContainerType = 'ldp:Container' | 'ldp:BasicContainer';\n\ninterface LDPContainerBase {\n  '@context': Configuration['jsonContext'];\n  id: string;\n  'ldp:contains': Record<string, any>[];\n}\n\ninterface LDPContainerWithType extends LDPContainerBase {\n  type: LDPContainerType | LDPContainerType[];\n}\n\ninterface LDPContainerWithAtType extends LDPContainerBase {\n  '@type': LDPContainerType | LDPContainerType[];\n}\n\ntype LDPContainer = LDPContainerWithType | LDPContainerWithAtType;\n\ntype LDPResource = {\n  '@context': Configuration['jsonContext'];\n  [key: string]: any;\n};\n\ntype ListFilters = Partial<{\n  q: string;\n  type: string;\n  _predicates: string[];\n  _servers: DataServerKey[];\n  [attribute: string]: any;\n}>;\n\nconst isValidLDPContainer = (container: LDPContainer) => {\n  const resourceType = (container as LDPContainerWithType).type || (container as LDPContainerWithAtType)['@type'];\n  return Array.isArray(resourceType) ? resourceType.includes('ldp:Container') : resourceType === 'ldp:Container';\n};\n\nconst isObject = (val: any) => {\n  return val != null && typeof val === 'object' && !Array.isArray(val);\n};\n\nconst fetchContainers = async (\n  containers: Record<DataServerKey, ContainerURI[]>,\n  params: GetListParams,\n  { httpClient, jsonContext }: Configuration\n) => {\n  const containersUri = Object.values(containers).flat();\n\n  const fetchPromises = containersUri.map(containerUri =>\n    httpClient(containerUri)\n      .then(async ({ json }) => {\n        const jsonResponse: LDPContainer = json;\n\n        // If container's context is different, compact it to have an uniform result\n        // TODO deep compare if the context is an object\n        if (jsonResponse['@context'] !== jsonContext) {\n          return jsonld.compact(jsonResponse, jsonContext as ContextDefinition) as unknown as Promise<LDPContainer>;\n        }\n\n        return jsonResponse;\n      })\n      .then((json: LDPContainer) => {\n        if (!isValidLDPContainer(json)) {\n          throw new Error(`${containerUri} is not a LDP container`);\n        }\n\n        return arrayOf(json['ldp:contains']).map<LDPResource>(resource => ({\n          '@context': json['@context'],\n          ...resource\n        }));\n      })\n  );\n\n  // Fetch simultaneously all containers\n  const results = await Promise.all(fetchPromises);\n  let resources = results.flat();\n\n  resources = resources.map(resource => {\n    resource.id = resource.id || resource['@id'];\n    return resource;\n  });\n\n  // Apply filter to results\n  const filters: ListFilters = params.filter;\n\n  // For SPARQL queries, we use \"a\" to filter types, but in containers it must be \"type\"\n  if (filters.a) {\n    filters.type = filters.a;\n    delete filters.a;\n  }\n\n  // Filter resources attributes according to _predicates list\n  if (filters._predicates && Array.isArray(filters._predicates)) {\n    const predicates = filters._predicates;\n    const mandatoryAttributes = ['id'];\n\n    resources = resources.map(resource => {\n      return Object.keys(resource)\n        .filter(key => predicates.includes(key) || mandatoryAttributes.includes(key))\n        .reduce<LDPResource>(\n          (filteredResource, key) => {\n            filteredResource[key] = resource[key];\n            return filteredResource;\n          },\n          { '@context': [] }\n        );\n    });\n  }\n\n  if (Object.keys(filters).filter(f => !['_predicates', '_servers'].includes(f)).length > 0) {\n    resources = resources.filter(resource => {\n      // Full text filtering\n      if (filters.q) {\n        return Object.values(resource).some(attributeValue => {\n          if (!isObject(attributeValue)) {\n            const arrayValues = Array.isArray(attributeValue) ? attributeValue : [attributeValue];\n            return arrayValues.some(value => {\n              if (typeof value === 'string') {\n                return value.toLowerCase().normalize('NFD').includes(filters.q!.toLowerCase().normalize('NFD'));\n              }\n              return false;\n            });\n          }\n          return false;\n        });\n      }\n\n      // Attribute filtering\n      const attributesFilters = Object.keys(filters).filter(f => !['_predicates', '_servers', 'q'].includes(f));\n\n      return attributesFilters.every(attribute => {\n        if (resource[attribute]) {\n          const arrayValues: any[] = Array.isArray(resource[attribute]) ? resource[attribute] : [resource[attribute]];\n          return arrayValues.some(\n            (value: any) => typeof value === 'string' && value.includes(filters[attribute] as string)\n          );\n        }\n\n        return false;\n      });\n    });\n  }\n\n  // Sorting\n  if (params.sort) {\n    resources = resources.sort((a, b) => {\n      if (a[params.sort.field] && b[params.sort.field]) {\n        if (params.sort.order === 'ASC') {\n          return a[params.sort.field].localeCompare(b[params.sort.field]);\n        }\n        return b[params.sort.field].localeCompare(a[params.sort.field]);\n      }\n      return true;\n    });\n  }\n\n  // Pagination\n  const total = resources.length;\n\n  if (params.pagination) {\n    resources = resources.slice(\n      (params.pagination.page - 1) * params.pagination.perPage,\n      params.pagination.page * params.pagination.perPage\n    );\n  }\n\n  return { data: resources, total };\n};\n\nexport default fetchContainers;\n","const arrayOf = <T>(value: T | T[]) => {\n  // If the field is null-ish, we suppose there are no values.\n  if (!value) {\n    return [];\n  }\n  // Return as is.\n  if (Array.isArray(value)) {\n    return value;\n  }\n  // Single value is made an array.\n  return [value];\n};\n\nexport default arrayOf;\n","import jsonld from 'jsonld';\nimport getEmbedFrame from './getEmbedFrame';\nimport buildSparqlQuery from './buildSparqlQuery';\n\nconst compare = (a, b) => {\n  switch (typeof a) {\n    case 'string':\n      return a.localeCompare(b);\n    case 'number':\n    case 'bigint':\n      return a - b;\n    default:\n      return 0;\n  }\n};\n\nconst fetchSparqlEndpoints = async (containers, resourceId, params, config) => {\n  const { dataServers, resources, httpClient, jsonContext, ontologies } = config;\n  const dataModel = resources[resourceId];\n\n  const sparqlQueryPromises = Object.keys(containers).map(\n    serverKey =>\n      new Promise((resolve, reject) => {\n        const blankNodes = params.filter?.blankNodes || dataModel.list?.blankNodes;\n\n        // When the SPARQL request comes from the browser's URL, it comes as JSON string which must must be parsed\n        if (\n          params.filter?.sparqlWhere &&\n          (typeof params.filter.sparqlWhere === 'string' || params.filter.sparqlWhere instanceof String)\n        ) {\n          params.filter.sparqlWhere = JSON.parse(decodeURIComponent(params.filter.sparqlWhere));\n        }\n        const sparqlQuery = buildSparqlQuery({\n          containers: containers[serverKey],\n          params,\n          dataModel,\n          ontologies\n        });\n\n        httpClient(dataServers[serverKey].sparqlEndpoint, {\n          method: 'POST',\n          body: sparqlQuery\n        })\n          .then(({ json }) => {\n            // If we declared the blank nodes to dereference, embed only those blank nodes\n            // This solve problems which can occur when same-type resources are embedded in other resources\n            // To increase performances, you can set explicitEmbedOnFraming to false (make sure the result is still OK)\n            const frame =\n              blankNodes && dataModel.list?.explicitEmbedOnFraming !== false\n                ? {\n                    '@context': jsonContext,\n                    '@type': dataModel.types,\n                    '@embed': '@never',\n                    ...getEmbedFrame(blankNodes)\n                  }\n                : {\n                    '@context': jsonContext,\n                    '@type': dataModel.types\n                  };\n\n            // omitGraph option force results to be in a @graph, even if we have a single result\n            return jsonld.frame(json, frame, { omitGraph: false });\n          })\n          .then(compactJson => {\n            if (compactJson['@id']) {\n              const { '@context': context, ...rest } = compactJson;\n              compactJson = {\n                '@context': context,\n                '@graph': [rest]\n              };\n            }\n            resolve(\n              compactJson['@graph'].map(resource => ({ '@context': compactJson['@context'], ...resource })) || []\n            );\n          })\n          .catch(e => reject(e));\n      })\n  );\n\n  // Run simultaneous SPARQL queries\n  let results = await Promise.all(sparqlQueryPromises);\n\n  if (results.length === 0) {\n    return { data: [], total: 0 };\n  }\n  // Merge all results in one array\n  results = [].concat(...results);\n\n  // Add id in addition to @id, as this is what React-Admin expects\n  let returnData = results.map(item => {\n    item.id = item.id || item['@id'];\n    return item;\n  });\n\n  // TODO sort and paginate the results in the SPARQL query to improve performances\n  if (params.sort) {\n    returnData = returnData.sort((a, b) => {\n      if (a[params.sort.field] !== undefined && b[params.sort.field] !== undefined) {\n        if (params.sort.order === 'ASC') {\n          return compare(a[params.sort.field], b[params.sort.field]);\n        }\n        return compare(b[params.sort.field], a[params.sort.field]);\n      }\n      return 0;\n    });\n  }\n  if (params.pagination) {\n    returnData = returnData.slice(\n      (params.pagination.page - 1) * params.pagination.perPage,\n      params.pagination.page * params.pagination.perPage\n    );\n  }\n\n  return { data: returnData, total: results.length };\n};\n\nexport default fetchSparqlEndpoints;\n","const getEmbedFrame = blankNodes => {\n  let embedFrame = {};\n  let predicates;\n  if (blankNodes) {\n    for (const blankNode of blankNodes) {\n      if (blankNode.includes('/')) {\n        predicates = blankNode.split('/').reverse();\n      } else {\n        predicates = [blankNode];\n      }\n      embedFrame = {\n        ...embedFrame,\n        ...predicates.reduce(\n          (accumulator, predicate) => ({\n            [predicate]: {\n              '@embed': '@last',\n              ...accumulator\n            }\n          }),\n          {}\n        )\n      };\n    }\n    return embedFrame;\n  }\n};\n\nexport default getEmbedFrame;\n","import DataFactory from '@rdfjs/data-model';\nimport buildBaseQuery from './buildBaseQuery';\nimport buildBlankNodesQuery from './buildBlankNodesQuery';\nimport buildAutoDetectBlankNodesQuery from './buildAutoDetectBlankNodesQuery';\nimport resolvePrefix from './resolvePrefix';\n\nconst SparqlGenerator = require('sparqljs').Generator;\n\nconst { literal, namedNode, triple, variable } = DataFactory;\n\nconst generator = new SparqlGenerator({\n  /* prefixes, baseIRI, factory, sparqlStar */\n});\n\nconst reservedFilterKeys = ['q', 'sparqlWhere', 'blankNodes', 'blankNodesDepth', '_servers', '_predicates'];\n\nconst buildSparqlQuery = ({ containers, params, dataModel, ontologies }) => {\n  const blankNodes = params.filter?.blankNodes || dataModel.list?.blankNodes;\n  const predicates = params.filter?._predicates || dataModel.list?.predicates;\n  const blankNodesDepth = params.filter?.blankNodesDepth ?? dataModel.list?.blankNodesDepth ?? 2;\n  const filter = { ...dataModel.list?.filter, ...params.filter };\n  const baseQuery = buildBaseQuery(predicates, ontologies);\n\n  const sparqlJsParams = {\n    queryType: 'CONSTRUCT',\n    template: baseQuery.construct,\n    where: [],\n    type: 'query',\n    prefixes: Object.fromEntries(ontologies.map(ontology => [ontology.prefix, ontology.url]))\n  };\n\n  const containerWhere = [\n    {\n      type: 'values',\n      values: containers.map(containerUri => ({ '?containerUri': namedNode(containerUri) }))\n    },\n    triple(variable('containerUri'), namedNode('http://www.w3.org/ns/ldp#contains'), variable('s1')),\n    {\n      type: 'filter',\n      expression: {\n        type: 'operation',\n        operator: 'isiri',\n        args: [variable('s1')]\n      }\n    }\n  ];\n\n  let resourceWhere = [];\n\n  if (filter && Object.keys(filter).length > 0) {\n    const hasSPARQLFilter = filter.sparqlWhere && Object.keys(filter.sparqlWhere).length > 0;\n    const hasFullTextSearch = filter.q && filter.q.length > 0;\n\n    if (hasSPARQLFilter) {\n      /*\n        Example of usage :\n        {\n          \"sparqlWhere\": {\n            \"type\": \"bgp\",\n            \"triples\": [{\n              \"subject\": {\"termType\": \"Variable\", \"value\": \"s1\"},\n              \"predicate\": {\"termType\": \"NameNode\", \"value\": \"http://virtual-assembly.org/ontologies/pair#label\"},\n              \"object\": {\"termType\": \"Literal\", \"value\": \"My Organization\"}\n            }]\n          }\n        }\n      */\n      // initialize array in case of single value :\n      [].concat(filter.sparqlWhere).forEach(sw => {\n        resourceWhere.push(sw);\n      });\n    }\n\n    if (hasFullTextSearch) {\n      resourceWhere.push({\n        type: 'group',\n        patterns: [\n          {\n            queryType: 'SELECT',\n            variables: [variable('s1')],\n            where: [\n              triple(variable('s1'), variable('p1'), variable('o1')),\n              {\n                type: 'filter',\n                expression: {\n                  type: 'operation',\n                  operator: 'isliteral',\n                  args: [variable('o1')]\n                }\n              },\n              {\n                type: 'filter',\n                expression: {\n                  type: 'operation',\n                  operator: 'regex',\n                  args: [\n                    {\n                      type: 'operation',\n                      operator: 'lcase',\n                      args: [\n                        {\n                          type: 'operation',\n                          operator: 'str',\n                          args: [variable('o1')]\n                        }\n                      ]\n                    },\n                    literal(filter.q.toLowerCase(), '', namedNode('http://www.w3.org/2001/XMLSchema#string'))\n                  ]\n                }\n              }\n            ],\n            type: 'query'\n          }\n        ]\n      });\n    }\n\n    // Other filters\n    // SPARQL keyword a = filter based on the class of a resource (example => 'a': 'pair:OrganizationType')\n    // Other filters are based on a value (example => 'petr:hasAudience': 'http://localhost:3000/audiences/tout-public')\n    Object.entries(filter).forEach(([predicate, object]) => {\n      if (!reservedFilterKeys.includes(predicate)) {\n        resourceWhere.unshift(\n          triple(\n            variable('s1'),\n            namedNode(resolvePrefix(predicate, ontologies)),\n            namedNode(resolvePrefix(object, ontologies))\n          )\n        );\n      }\n    });\n  }\n\n  // Blank nodes\n  const blankNodesQuery = blankNodes\n    ? buildBlankNodesQuery(blankNodes, baseQuery, ontologies)\n    : buildAutoDetectBlankNodesQuery(blankNodesDepth, baseQuery);\n\n  if (blankNodesQuery && blankNodesQuery.construct) {\n    resourceWhere = resourceWhere.concat(blankNodesQuery.where);\n    sparqlJsParams.template = sparqlJsParams.template.concat(blankNodesQuery.construct);\n  } else {\n    resourceWhere.push(baseQuery.where);\n  }\n\n  sparqlJsParams.where.push(\n    {\n      type: 'union',\n      patterns: [\n        containerWhere,\n        {\n          type: 'graph',\n          name: namedNode('http://semapps.org/mirror'),\n          patterns: containerWhere\n        }\n      ]\n    },\n    {\n      type: 'union',\n      patterns: [\n        resourceWhere,\n        {\n          type: 'graph',\n          name: namedNode('http://semapps.org/mirror'),\n          patterns: resourceWhere\n        }\n      ]\n    }\n  );\n\n  return generator.stringify(sparqlJsParams);\n};\n\nexport default buildSparqlQuery;\n","import { namedNode, triple, variable } from '@rdfjs/data-model';\nimport resolvePrefix from './resolvePrefix';\n\nconst defaultToArray = value => (!value ? [] : Array.isArray(value) ? value : [value]);\n\n// We need to always include the type or React-Admin will not work properly\nconst typeQuery = triple(\n  variable('s1'),\n  namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),\n  variable('type')\n);\n\nconst buildBaseQuery = (predicates, ontologies) => {\n  let baseTriples;\n  if (predicates) {\n    baseTriples = defaultToArray(predicates).map((predicate, i) =>\n      triple(variable('s1'), namedNode(resolvePrefix(predicate, ontologies)), variable(`o${i + 1}`))\n    );\n    return {\n      construct: [typeQuery, ...baseTriples],\n      where: [typeQuery, ...baseTriples.map(triple => ({ type: 'optional', patterns: [triple] }))]\n    };\n  }\n  baseTriples = [triple(variable('s1'), variable('p1'), variable('o1'))];\n  return {\n    construct: baseTriples,\n    where: baseTriples\n  };\n};\n\nexport default buildBaseQuery;\n","const resolvePrefix = (item, ontologies) => {\n  if (item.startsWith('http://') || item.startsWith('https://')) {\n    // Already resolved, return the URI\n    return item;\n  }\n  if (item === 'a') {\n    // Special case\n    return 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type';\n  }\n  const [prefix, value] = item.split(':');\n  if (value) {\n    const ontology = ontologies.find(ontology => ontology.prefix === prefix);\n    if (ontology) {\n      return ontology.url + value;\n    }\n    throw new Error(`No ontology found with prefix ${prefix}`);\n  } else {\n    throw new Error(`The value \"${item}\" is not correct. It must include a prefix or be a full URI.`);\n  }\n};\n\nexport default resolvePrefix;\n","import md5 from 'crypto-js/md5';\nimport { namedNode, triple, variable } from '@rdfjs/data-model';\nimport resolvePrefix from './resolvePrefix';\n\n// Transform ['ont:predicate1/ont:predicate2'] to ['ont:predicate1', 'ont:predicate1/ont:predicate2']\nconst extractNodes = blankNodes => {\n  const nodes = [];\n  if (blankNodes) {\n    for (const predicate of blankNodes) {\n      if (predicate.includes('/')) {\n        const nodeNames = predicate.split('/');\n        for (let i = 1; i <= nodeNames.length; i++) {\n          nodes.push(nodeNames.slice(0, i).join('/'));\n        }\n      } else {\n        nodes.push(predicate);\n      }\n    }\n  }\n  return nodes;\n};\n\nconst generateSparqlVarName = node => md5(node);\n\nconst getParentNode = node => node.includes('/') && node.split('/')[0];\n\nconst getPredicate = node => (node.includes('/') ? node.split('/')[1] : node);\n\nconst buildUnionQuery = queries =>\n  queries.map(q => {\n    let triples = q.query;\n    const firstTriple = queries.find(q2 => q.parentNode === q2.node);\n    if (firstTriple !== undefined) {\n      triples = triples.concat(firstTriple.query[0]);\n    }\n    return {\n      type: 'bgp',\n      triples\n    };\n  });\n\nconst buildBlankNodesQuery = (blankNodes, baseQuery, ontologies) => {\n  const queries = [];\n  const nodes = extractNodes(blankNodes);\n\n  if (nodes && ontologies && ontologies.length > 0) {\n    for (const node of nodes) {\n      const parentNode = getParentNode(node);\n      const predicate = getPredicate(node);\n      const varName = generateSparqlVarName(node);\n      const parentVarName = parentNode ? generateSparqlVarName(parentNode) : '1';\n\n      const query = [\n        triple(variable(`s${parentVarName}`), namedNode(resolvePrefix(predicate, ontologies)), variable(`s${varName}`)),\n        triple(variable(`s${varName}`), variable(`p${varName}`), variable(`o${varName}`))\n      ];\n\n      queries.push({\n        node,\n        parentNode,\n        query,\n        filter: '' // `FILTER(isBLANK(?s${varName})) .`\n      });\n    }\n\n    return {\n      construct: queries.length > 0 ? queries.map(q => q.query).reduce((pre, cur) => pre.concat(cur)) : null,\n      where: {\n        type: 'union',\n        patterns: [baseQuery.where, ...buildUnionQuery(queries)]\n      }\n    };\n  }\n  return {\n    construct: '',\n    where: ''\n  };\n};\n\nexport default buildBlankNodesQuery;\n","import { triple, variable } from '@rdfjs/data-model';\n\nconst buildAutoDetectBlankNodesQuery = (depth, baseQuery) => {\n  const construct = [...baseQuery.construct];\n  let where = {};\n  if (depth > 0) {\n    const whereQueries = [];\n    whereQueries.push([baseQuery.where]);\n    for (let i = 1; i <= depth; i++) {\n      construct.push(triple(variable(`o${i}`), variable(`p${i + 1}`), variable(`o${i + 1}`)));\n      whereQueries.push([\n        ...whereQueries[whereQueries.length - 1],\n        {\n          type: 'filter',\n          expression: {\n            type: 'operation',\n            operator: 'isblank',\n            args: [variable(`o${i}`)]\n          }\n        },\n        triple(variable(`o${i}`), variable(`p${i + 1}`), variable(`o${i + 1}`))\n      ]);\n    }\n    where = {\n      type: 'union',\n      patterns: whereQueries\n    };\n  } else if (depth === 0) {\n    where = baseQuery.where;\n  } else {\n    throw new Error('The depth of buildAutoDetectBlankNodesQuery should be 0 or more');\n  }\n\n  return { construct, where };\n};\n\nexport default buildAutoDetectBlankNodesQuery;\n","import urlJoin from 'url-join';\n\nconst findContainersWithPaths = (paths, dataServers) => {\n  const containers = {};\n  Object.keys(paths).forEach(serverKey => {\n    if (dataServers[serverKey]) {\n      containers[serverKey] = [];\n      paths[serverKey].forEach(path => {\n        containers[serverKey].push(urlJoin(dataServers[serverKey].baseUrl, path));\n      });\n    } else {\n      throw new Error(`No server found with key ${serverKey}`);\n    }\n  });\n  return containers;\n};\n\nexport default findContainersWithPaths;\n","import getOne from './getOne';\n\nconst getManyMethod = config => async (resourceId, params) => {\n  const { returnFailedResources } = config;\n\n  let returnData = await Promise.all(\n    params.ids.map(id =>\n      getOne(config)(resourceId, { id: typeof id === 'object' ? id['@id'] : id })\n        .then(({ data }) => data)\n        .catch(() => {\n          // Catch if one resource fails to load\n          // Otherwise no references will be show if only one is missing\n          // See https://github.com/marmelab/react-admin/issues/5190\n          if (returnFailedResources) {\n            return { id, _error: true };\n          }\n          // Returning nothing\n        })\n    )\n  );\n\n  // We don't want undefined results to appear in the results as it will break with react-admin\n  returnData = returnData.filter(e => e);\n\n  return { data: returnData };\n};\n\nexport default getManyMethod;\n","import getList from './getList';\n\nconst getManyReferenceMethod = config => async (resourceId, params) => {\n  params.filter = { ...params.filter, [params.target]: params.id };\n  delete params.target;\n  return await getList(config)(resourceId, params);\n};\n\nexport default getManyReferenceMethod;\n","import { RaRecord } from 'react-admin';\nimport { Generator as SparqlGenerator, Update } from 'sparqljs';\nimport { Configuration, PatchParams } from '../types';\n\nconst generator = new SparqlGenerator();\n\nconst patchMethod = (config: Configuration) => async (resourceId: string, params: PatchParams<RaRecord>) => {\n  const { httpClient } = config;\n\n  const sparqlUpdate = {\n    type: 'update',\n    prefixes: {},\n    updates: []\n  } as Update;\n\n  if (params.triplesToAdd) {\n    sparqlUpdate.updates.push({\n      updateType: 'insert',\n      insert: [{ type: 'bgp', triples: params.triplesToAdd }]\n    });\n  }\n\n  if (params.triplesToRemove) {\n    sparqlUpdate.updates.push({\n      updateType: 'delete',\n      delete: [{ type: 'bgp', triples: params.triplesToRemove }]\n    });\n  }\n\n  await httpClient(`${params.id}`, {\n    method: 'PATCH',\n    headers: new Headers({\n      'Content-Type': 'application/sparql-update'\n    }),\n    body: generator.stringify(sparqlUpdate)\n  });\n};\n\nexport default patchMethod;\n","import { RaRecord, UpdateParams } from 'react-admin';\nimport { Configuration } from '../types';\nimport handleFiles from '../utils/handleFiles';\n\nconst updateMethod = (config: Configuration) => async (resourceId: string, params: UpdateParams<RaRecord>) => {\n  const { httpClient, jsonContext } = config;\n\n  // Upload files, if there are any\n  const { updatedRecord, filesToDelete } = await handleFiles.upload(params.data, config);\n  params.data = updatedRecord;\n\n  await httpClient(`${params.id}`, {\n    method: 'PUT',\n    body: JSON.stringify({\n      '@context': jsonContext,\n      ...params.data\n    })\n  });\n\n  // Delete files only if update is successful\n  await handleFiles.delete(filesToDelete, config);\n\n  return { data: params.data };\n};\n\nexport default updateMethod;\n","import jwtDecode from 'jwt-decode';\nimport urlJoin from 'url-join';\nimport getServerKeyFromType from './getServerKeyFromType';\n\nconst fetchUserConfig = async config => {\n  const { dataServers, httpClient } = config;\n  const token = localStorage.getItem('token');\n  const podKey = getServerKeyFromType('pod', dataServers);\n  const authServerKey = getServerKeyFromType('authServer', dataServers);\n\n  // If the user is logged in\n  if (token) {\n    const payload = jwtDecode(token);\n    const webId = payload.webId || payload.webid; // Currently we must deal with both formats\n    let userData;\n\n    try {\n      const { json } = await httpClient(webId);\n      userData = json;\n    } catch (e) {\n      console.error(e);\n      // If the webId cannot be fetched, assume an invalid token and disconnect the user\n      localStorage.clear();\n      window.location.reload();\n      return;\n    }\n\n    // If we have a POD server\n    if (podKey) {\n      // Fill the config provided to the data provider\n      // We must modify the config object directly\n      config.dataServers[podKey].name = 'My Pod';\n      config.dataServers[podKey].baseUrl = urlJoin(webId, 'data'); // TODO find POD URI from user profile\n      config.dataServers[podKey].sparqlEndpoint =\n        userData.endpoints?.['void:sparqlEndpoint'] || urlJoin(webId, 'sparql');\n    }\n\n    if (authServerKey) {\n      // Fill the config provided to the data provider\n      // We must modify the config object directly\n      config.dataServers[authServerKey].proxyUrl = userData.endpoints?.proxyUrl;\n    }\n  } else if (podKey) {\n    // If the user is not logged in, ignore the POD server\n    delete config.dataServers[podKey];\n  }\n};\n\nexport default fetchUserConfig;\n","const defaultToArray = value => (!value ? undefined : Array.isArray(value) ? value : [value]);\n\nconst fetchVoidEndpoints = async config => {\n  const fetchPromises = Object.entries(config.dataServers)\n    .filter(([key, server]) => server.pod !== true && server.void !== false)\n    .map(([key, server]) =>\n      config\n        .httpClient(new URL('/.well-known/void', server.baseUrl).toString())\n        .then(result => ({ key, datasets: result.json['@graph'] }))\n        .catch(e => {\n          if (e.status === 404 || e.status === 401 || e.status === 500) {\n            return { key, error: e };\n          }\n          throw e;\n        })\n    );\n\n  let results = [];\n\n  try {\n    results = await Promise.all(fetchPromises);\n  } catch (e) {\n    // Do not throw error if no endpoint found\n  }\n\n  for (const result of results) {\n    config.dataServers[result.key].containers = config.dataServers[result.key].containers || {};\n    config.dataServers[result.key].blankNodes = config.dataServers[result.key].blankNodes || {};\n\n    // Ignore unfetchable endpoints\n    if (result.datasets) {\n      for (const dataset of result.datasets) {\n        const datasetServerKey = Object.keys(config.dataServers).find(\n          key => dataset['void:uriSpace'] === config.dataServers[key].baseUrl\n        );\n\n        // If the dataset is not part of a server mapped in the dataServers, ignore it\n        if (datasetServerKey) {\n          // If this is the local dataset, add the base information\n          if (datasetServerKey === result.key) {\n            config.dataServers[result.key].name = config.dataServers[result.key].name || dataset['dc:title'];\n            config.dataServers[result.key].description =\n              config.dataServers[result.key].description || dataset['dc:description'];\n            config.dataServers[result.key].sparqlEndpoint =\n              config.dataServers[result.key].sparqlEndpoint || dataset['void:sparqlEndpoint'];\n          }\n\n          config.dataServers[result.key].containers[datasetServerKey] =\n            config.dataServers[result.key].containers[datasetServerKey] || {};\n\n          for (const partition of defaultToArray(dataset['void:classPartition'])) {\n            for (const type of defaultToArray(partition['void:class'])) {\n              // Set containers by type\n              const path = partition['void:uriSpace'].replace(dataset['void:uriSpace'], '/');\n              if (config.dataServers[result.key].containers[datasetServerKey][type]) {\n                config.dataServers[result.key].containers[datasetServerKey][type].push(path);\n              } else {\n                config.dataServers[result.key].containers[datasetServerKey][type] = [path];\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n};\n\nexport default fetchVoidEndpoints;\n","import { fetchUtils } from 'react-admin';\nimport getServerKeyFromUri from './utils/getServerKeyFromUri';\nimport getServerKeyFromType from './utils/getServerKeyFromType';\n\n/*\n * HTTP client used by all calls in data provider and auth provider\n * Do proxy calls if a proxy endpoint is available and the server is different from the auth server\n */\nconst httpClient =\n  dataServers =>\n  (url, options = {}) => {\n    const authServerKey = getServerKeyFromType('authServer', dataServers);\n    const serverKey = getServerKeyFromUri(url, dataServers);\n    const useProxy =\n      serverKey !== authServerKey && dataServers[authServerKey]?.proxyUrl && dataServers[serverKey]?.noProxy !== true;\n\n    if (!options.headers) options.headers = new Headers();\n\n    switch (options.method) {\n      case 'POST':\n      case 'PATCH':\n      case 'PUT':\n        if (!options.headers.has('Accept')) options.headers.set('Accept', 'application/ld+json');\n        if (!options.headers.has('Content-Type')) options.headers.set('Content-Type', 'application/ld+json');\n        break;\n\n      case 'DELETE':\n        break;\n\n      case 'GET':\n      default:\n        if (!options.headers.has('Accept')) options.headers.set('Accept', 'application/ld+json');\n        break;\n    }\n\n    if (useProxy) {\n      const formData = new FormData();\n\n      formData.append('id', url);\n      formData.append('method', options.method || 'GET');\n      formData.append('headers', JSON.stringify(Object.fromEntries(options.headers.entries())));\n\n      if (options.body) {\n        if (options.body instanceof File) {\n          formData.append('body', options.body, options.body.name);\n        } else {\n          formData.append('body', options.body);\n        }\n      }\n\n      // Post to proxy endpoint with multipart/form-data format\n      return fetchUtils.fetchJson(dataServers[authServerKey].proxyUrl, {\n        method: 'POST',\n        headers: new Headers({\n          Authorization: `Bearer ${localStorage.getItem('token')}`\n        }),\n        body: formData\n      });\n    }\n    // Add token if the server is the same as the auth server\n    if (serverKey === authServerKey) {\n      const token = localStorage.getItem('token');\n      if (token) options.headers.set('Authorization', `Bearer ${token}`);\n    }\n    return fetchUtils.fetchJson(url, options);\n  };\n\nexport default httpClient;\n","// Return the first server matching with the baseUrl\nconst getServerKeyFromUri = (uri, dataServers) => {\n  if (!uri) throw Error(`No URI provided to getServerKeyFromUri`);\n  return Object.keys(dataServers).find(key => {\n    if (dataServers[key].pod) {\n      // The baseUrl ends with /data so remove this part to match with the webId and webId-related URLs (/inbox, /outbox...)\n      return dataServers[key].baseUrl && uri.startsWith(dataServers[key].baseUrl.replace('/data', ''));\n    }\n    return uri.startsWith(dataServers[key].baseUrl);\n  });\n};\n\nexport default getServerKeyFromUri;\n","import { useCallback, useMemo, useContext } from 'react';\nimport { DataProviderContext } from 'react-admin';\n\nconst compute = (externalLinks, record) =>\n  typeof externalLinks === 'function' ? externalLinks(record) : externalLinks;\nconst isURL = url => typeof url === 'string' && url.startsWith('http');\n\nconst useGetExternalLink = componentExternalLinks => {\n  // Since the externalLinks config is defined only locally, we don't need to wait for VOID endpoints fetching\n  const dataProvider = useContext(DataProviderContext);\n  const dataServers = dataProvider.getLocalDataServers();\n\n  const serversExternalLinks = useMemo(() => {\n    if (dataServers) {\n      return Object.fromEntries(\n        Object.values(dataServers).map(server => {\n          // If externalLinks is not defined in the data server, use external links for non-default servers\n          const externalLinks = server.externalLinks !== undefined ? server.externalLinks : !server.default;\n          return [server.baseUrl, externalLinks];\n        })\n      );\n    }\n  }, [dataServers]);\n\n  return useCallback(\n    record => {\n      const computedComponentExternalLinks = compute(componentExternalLinks, record);\n      // If the component explicitly asks not to display as external links, use an internal link\n      if (computedComponentExternalLinks === false) return false;\n\n      if (!record?.id) return false;\n\n      const serverBaseUrl = Object.keys(serversExternalLinks).find(baseUrl => record?.id.startsWith(baseUrl));\n      // If no matching data servers could be found, assume we have an internal link\n      if (!serverBaseUrl) return false;\n\n      const computedServerExternalLinks = compute(serversExternalLinks[serverBaseUrl], record);\n      // If the data server explicitly asks not to display as external links, use an internal link\n      if (computedServerExternalLinks === false) return false;\n\n      if (isURL(computedComponentExternalLinks)) {\n        return computedComponentExternalLinks;\n      }\n      if (isURL(computedServerExternalLinks)) {\n        return computedServerExternalLinks;\n      }\n      return record.id;\n    },\n    [serversExternalLinks, componentExternalLinks]\n  );\n};\n\nexport default useGetExternalLink;\n","import { useState, useEffect } from 'react';\nimport useDataModel from './useDataModel';\nimport useDataServers from './useDataServers';\nimport findContainersWithTypes from '../dataProvider/utils/findContainersWithTypes';\nimport { DataServerKey } from '../dataProvider/types';\n\nconst useContainers = (resourceId: string, serverKeys = '@all') => {\n  const dataModel = useDataModel(resourceId);\n  const dataServers = useDataServers();\n  const [containers, setContainers] = useState<Record<DataServerKey, string[]>>();\n\n  useEffect(() => {\n    if (dataModel && dataServers) {\n      setContainers(findContainersWithTypes(dataModel.types, serverKeys, dataServers));\n    }\n  }, [dataModel, dataServers, serverKeys]);\n\n  return containers;\n};\n\nexport default useContainers;\n","import { useContext, useState, useEffect } from 'react';\nimport { DataProviderContext } from 'react-admin';\n\nconst useDataModel = (resourceId: string) => {\n  // Get the raw data provider, since useDataProvider returns a wrapper\n  const dataProvider = useContext(DataProviderContext);\n  const [dataModel, setDataModel] = useState<any>(undefined); // TODO: Type this object\n\n  useEffect(() => {\n    dataProvider.getDataModels().then((results: any) => setDataModel(results[resourceId]));\n  }, [dataProvider, resourceId, setDataModel]);\n\n  return dataModel;\n};\n\nexport default useDataModel;\n","import { useState, useEffect } from 'react';\nimport { useDataProvider } from 'react-admin';\nimport { DataProvider, DataServersConfig } from '../dataProvider/types';\n\nconst useDataServers = () => {\n  const dataProvider = useDataProvider<DataProvider>();\n  const [dataServers, setDataServers] = useState<DataServersConfig>();\n\n  useEffect(() => {\n    dataProvider.getDataServers().then(results => {\n      setDataServers(results);\n    });\n  }, [dataProvider, setDataServers]);\n\n  return dataServers;\n};\n\nexport default useDataServers;\n","import { useState, useEffect } from 'react';\nimport urlJoin from 'url-join';\nimport useDataModel from './useDataModel';\nimport useDataServers from './useDataServers';\nimport findCreateContainerWithTypes from '../dataProvider/utils/findCreateContainerWithTypes';\nimport getServerKeyFromType from '../dataProvider/utils/getServerKeyFromType';\n\n/** @deprecated Use \"useCreateContainerUri\" instead */\nconst useCreateContainer = resourceId => {\n  const dataModel = useDataModel(resourceId);\n  const dataServers = useDataServers();\n  const [createContainer, setCreateContainer] = useState();\n\n  useEffect(() => {\n    if (dataModel && dataServers) {\n      if (dataModel.create?.container) {\n        const [serverKey, path] = Object.entries(dataModel.create.container)[0];\n        if (!serverKey || !dataServers[serverKey]) {\n          throw new Error(`Wrong key for the dataModel.create.container config of resource ${resourceId}`);\n        }\n        setCreateContainer(urlJoin(dataServers[serverKey].baseUrl, path));\n      } else if (dataModel.create?.server) {\n        setCreateContainer(findCreateContainerWithTypes(dataModel.types, dataModel.create?.server, dataServers));\n      } else {\n        const defaultServerKey = getServerKeyFromType('default', dataServers);\n        setCreateContainer(findCreateContainerWithTypes(dataModel.types, defaultServerKey, dataServers));\n      }\n    }\n  }, [dataModel, dataServers, setCreateContainer]);\n\n  return createContainer;\n};\n\nexport default useCreateContainer;\n","import urlJoin from 'url-join';\nimport { DataModel, DataServerKey, DataServersConfig } from '../types';\n\nconst findCreateContainerWithTypes = (\n  types: DataModel['types'],\n  createServerKey: DataServerKey,\n  dataServers: DataServersConfig\n) => {\n  const containers: string[] = [];\n\n  Object.keys(dataServers[createServerKey].containers?.[createServerKey] || {}).forEach(type => {\n    if (types.includes(type)) {\n      dataServers[createServerKey].containers![createServerKey][type].forEach(path => {\n        const containerUri = urlJoin(dataServers[createServerKey].baseUrl, path);\n        if (!containers.includes(containerUri)) {\n          containers.push(containerUri);\n        }\n      });\n    }\n  });\n\n  if (containers.length === 0) {\n    throw new Error(\n      `No container found matching with types ${JSON.stringify(\n        types\n      )}. You can set explicitely the create.container property of the resource.`\n    );\n  } else if (containers.length > 1) {\n    throw new Error(\n      `More than one container found matching with types ${JSON.stringify(\n        types\n      )}. You must set the create.server or create.container property for the resource.`\n    );\n  }\n\n  return containers[0];\n};\n\nexport default findCreateContainerWithTypes;\n","import { useCallback } from 'react';\nimport urlJoin from 'url-join';\nimport useDataServers from './useDataServers';\nimport findCreateContainerWithTypes from '../dataProvider/utils/findCreateContainerWithTypes';\nimport getServerKeyFromType from '../dataProvider/utils/getServerKeyFromType';\nimport useDataModels from './useDataModels';\n\nconst useCreateContainerUri = () => {\n  const dataModels = useDataModels();\n  const dataServers = useDataServers();\n\n  const getContainerUri = useCallback(\n    (resourceId: string) => {\n      if (!dataModels || !dataServers || !dataModels[resourceId]) {\n        return undefined;\n      }\n\n      const dataModel = dataModels[resourceId];\n\n      if (dataModel.create?.container) {\n        const [serverKey, path] = Object.entries(dataModel.create.container)[0];\n        if (!serverKey || !dataServers[serverKey]) {\n          throw new Error(`Wrong key for the dataModel.create.container config of resource ${resourceId}`);\n        }\n        return urlJoin(dataServers[serverKey].baseUrl, path);\n      }\n\n      if (dataModel.create?.server) {\n        return findCreateContainerWithTypes(dataModel.types, dataModel.create?.server, dataServers);\n      }\n\n      const defaultServerKey = getServerKeyFromType('default', dataServers);\n\n      if (!defaultServerKey) {\n        throw new Error(\n          `No default dataServer found. You can set explicitly one setting the \"default\" attribute to true`\n        );\n      }\n\n      return findCreateContainerWithTypes(dataModel.types, defaultServerKey, dataServers);\n    },\n    [dataModels, dataServers]\n  );\n\n  return getContainerUri;\n};\n\nexport default useCreateContainerUri;\n","import { useState, useEffect } from 'react';\nimport { useDataProvider } from 'react-admin';\nimport { DataModel, DataProvider } from '../dataProvider/types';\n\nconst useDataModels = () => {\n  const dataProvider = useDataProvider<DataProvider>();\n  const [dataModels, setDataModels] = useState<Record<string, DataModel>>();\n\n  useEffect(() => {\n    dataProvider.getDataModels().then(results => {\n      setDataModels(results);\n    });\n  }, [dataProvider, setDataModels]);\n\n  return dataModels;\n};\n\nexport default useDataModels;\n","import React, { useState, useEffect } from 'react';\n\n/**\n * @example\n * <Show>\n *   <FilterHandler\n *     source=\"property\" // ex pair:organizationOfMembership\n *     filter={{\n *       'propertyToFilter':'value'\n *     }} // ex {{'pair:membershipRole':'http://localhost:3000/membership-roles/role-1'}}\n *     >\n *     <SingleFieldList>\n *    </SingleFieldList>\n *   </FilterHandler>\n * </Show>\n */\n\nconst FilterHandler = ({ children, record, filter, source, ...otherProps }) => {\n  const [filtered, setFiltered] = useState();\n  useEffect(() => {\n    if (record && source && Array.isArray(record?.[source])) {\n      const filteredData = record?.[source].filter(r => {\n        let eq = true;\n        for (const key in filter) {\n          const value = r[key];\n          if (Array.isArray(value)) {\n            if (!value.includes(filter[key])) {\n              eq = false;\n            }\n          } else if (value !== filter[key]) {\n            eq = false;\n          }\n        }\n        return eq;\n      });\n      const newRecord = {\n        ...record\n      };\n      // undefined setted if no data to obtain no render in RightLabel or equivalent\n      newRecord[source] = filteredData.length > 0 ? filteredData : undefined;\n      setFiltered(newRecord);\n    }\n  }, [record, source, filter]);\n\n  return (\n    <>\n      {React.Children.map(children, (child, i) => {\n        return React.cloneElement(child, {\n          ...otherProps,\n          record: filtered,\n          source\n        });\n      })}\n    </>\n  );\n};\nexport default FilterHandler;\n","import React from 'react';\nimport { useGetList, useRecordContext } from 'react-admin';\nimport { default as FilterHandler } from './FilterHandler';\n\n/*\n * @example Label used in examples\n *  const Label = ({label, ...otherProps})=>{\n *     return <h2>{label}</h2>\n *  }\n *\n * @example show header for each group with group property thanks to groupHeader\n * <GroupedReferenceHandler\n *   source=\"property\" // predicat of main record to show / ex pair:organizationOfMembership\n *   groupReference=\"RAresource\" // React-Admin resource reference. this is the \"group by\" ressource. / ex MembershipRole\n *   groupHeader={({group,...otherProps}) => <Label {...otherProps} label={group['pair:label']}></Label> }\n *   filterProperty=\"property of source filtered by groupReference\"\n * >\n *   <ArrayField source=\"property\"> // same props as GroupedArrayField source\n *    <ImageList>\n *    </ImageList>\n *   </ArrayField>\n * </GroupedReferenceHandler>\n *\n * @example call chhildren with label thanks to groupLabel\n * <GroupedReferenceHandler\n *   source=\"property\" // predicat of main record to show / ex pair:organizationOfMembership\n *   groupReference=\"RAresource\" // React-Admin resource reference. this is the \"group by\" ressource. / ex MembershipRole\n *   groupLabel=\"property of RAresource display\" // property of React-Admin resource to display. children call whith props \"label\" filled by groupLabel property of groupReference\n *   filterProperty=\"property of source filtered by groupReference\"\n * >\n *   <Label>\n *   <ArrayField source=\"property\"> // same props as GroupedArrayField source\n *    <ImageList>\n *    </ImageList>\n *   </ArrayField>\n * </GroupedReferenceHandler>\n *\n * @example conditional show of group if no data in source. Conditionale groupHeader is not possible because GroupedArrayField define group before filter ; need use chhildren.\n * const ConditionalSourceDefinedHandler = ({record,source,children,...otherProps})=>{\n *   if (record?.[source] && (!Array.isArray(record[source])||record[source].length>0)){\n *     return  React.Children.map(children, (child, i) => {\n *         return React.cloneElement(child, {...otherProps,record,source});\n *       })\n *   }else{\n *     return <></>\n *   }\n * }\n *\n * <GroupedReferenceHandler\n *   source=\"property\" // predicat of main record to show / ex pair:organizationOfMembership\n *   groupReference=\"RAresource\" // React-Admin resource reference. this is the \"group by\" ressource. / ex MembershipRole\n *   groupLabel=\"property of RAresource display\" // property of React-Admin resource to display. children call whith props \"label\" filled by groupLabel property of groupReference\n *   filterProperty=\"property of source filtered by groupReference\"\n * >\n *  <ConditionalSourceDefinedHandler>\n *   <Label>\n *   <ArrayField source=\"property\"> // same props as GroupedArrayField source\n *    <ImageList>\n *    </ImageList>\n *   </ArrayField>\n *  </ConditionalSourceDefinedHandler>\n * </GroupedReferenceHandler>\n *\n *\n */\nconst GroupedReferenceHandler = ({\n  children,\n  groupReference,\n  groupLabel,\n  groupHeader,\n  filterProperty,\n  ...otherProps\n}) => {\n  const record = useRecordContext();\n  const { data } = useGetList(groupReference);\n\n  return (\n    <>\n      {data?.map((data, index) => {\n        const filter = {};\n        filter[filterProperty] = data.id;\n        return (\n          <>\n            {groupHeader && groupHeader({ ...otherProps, group: data })}\n            <FilterHandler {...otherProps} record={record} filter={filter} label={data[groupLabel]}>\n              {children}\n            </FilterHandler>\n          </>\n        );\n      })}\n    </>\n  );\n};\n\nexport default GroupedReferenceHandler;\n","import React, { useEffect, useState } from 'react';\nimport { ArrayInput, SimpleFormIterator, TextInput } from 'react-admin';\nimport makeStyles from '@mui/styles/makeStyles';\n\nconst useReferenceInputStyles = makeStyles({\n  form: {\n    display: 'flex'\n  },\n  input: {\n    paddingRight: '20px'\n  }\n});\n\nconst useHideInputStyles = makeStyles({\n  root: {\n    display: 'none'\n  }\n});\n\nconst ReificationArrayInput = props => {\n  const { reificationClass, children, ...otherProps } = props;\n  const flexFormClasses = useReferenceInputStyles();\n  const hideInputStyles = useHideInputStyles();\n\n  return (\n    <ArrayInput {...otherProps}>\n      <SimpleFormIterator classes={{ form: flexFormClasses.form }}>\n        {React.Children.map(props.children, (child, i) => {\n          return React.cloneElement(child, {\n            className: flexFormClasses.input\n          });\n        })}\n        <TextInput className={hideInputStyles.root} source=\"type\" initialValue={reificationClass} />\n      </SimpleFormIterator>\n    </ArrayInput>\n  );\n};\n\nexport default ReificationArrayInput;\n","import { fetchUtils } from 'react-admin';\nimport arrayOf from '../dataProvider/utils/arrayOf';\n\n/*\n * Utility functions for subscribing to resource update using Solid Notifications.\n * See https://solidproject.org/TR/notifications-protocol for an overview.\n */\n\ntype fetchFn = typeof fetchUtils.fetchJson;\n\ninterface CreateSolidChannelOptions {\n  type: string;\n  closeAfter?: number;\n  startIn?: number;\n  startAt?: string;\n  endAt?: string;\n  rate?: number;\n}\n\n/**\n * Find the solid notification description resource for a given resource URI.\n */\nconst findDescriptionResource = async (fetch: fetchFn, resourceUri: string) => {\n  const { headers } = await fetch(resourceUri, { method: 'HEAD' });\n  const linkHeader = headers.get('Link');\n\n  const matches = linkHeader?.match(\n    /<([^>]+)>;\\s*rel=\"(?:describedby|http:\\/\\/www\\.w3\\.org\\/ns\\/solid\\/terms#storageDescription)\"/\n  );\n  if (!matches?.[1]) {\n    return undefined;\n    // matches[1] contains the URI of the description resource\n    // Further actions can be taken here, such as subscribing to the websocket using the description resource URI\n  }\n  const { json: descriptionResource } = await fetch(matches[1]);\n  return descriptionResource;\n};\n\nconst createSolidNotificationChannel = async (\n  fetch: fetchFn,\n  resourceUri: string,\n  options: CreateSolidChannelOptions = { type: 'WebSocketChannel2023' }\n) => {\n  const { type, closeAfter, startIn, rate } = options;\n  let { startAt, endAt } = options;\n  if (startIn && !startAt) startAt = new Date(Date.now() + startIn).toISOString();\n  if (closeAfter && !endAt) endAt = new Date(Date.now() + closeAfter).toISOString();\n\n  const descriptionResource = await findDescriptionResource(fetch, resourceUri);\n\n  // TODO: use a json-ld parser / ldo in the future for this...\n  // Get solid notification subscription service for the given type.\n  const subscriptionService = (\n    await Promise.all(\n      // Get the subscription service resources (that describe a channel type).\n      arrayOf(descriptionResource.subscription || descriptionResource['notify:subscription']).map(\n        async subscriptionServiceOrUri => {\n          // They might not be resolved...\n          if (typeof subscriptionServiceOrUri === 'string') {\n            const { json } = await fetch(subscriptionServiceOrUri);\n            return json;\n          }\n          return subscriptionServiceOrUri;\n        }\n      )\n    )\n  ).find((service: any) => {\n    // Find for the correct channel type (e.g. web socket).\n    const channelType = service.channelType ?? service['notify:channelType'];\n    return channelType === type || channelType === `notify:${type}`;\n  });\n\n  if (!subscriptionService) {\n    throw new Error(`No solid notification subscription service found for type ${type}`);\n  }\n\n  // Create a new channel.\n  const { json: channel } = await fetch(subscriptionService.id || subscriptionService['@id'], {\n    method: 'POST',\n    body: JSON.stringify({\n      '@context': 'https://www.w3.org/ns/solid/notification/v1',\n      type: 'WebSocketChannel2023',\n      topic: resourceUri,\n      startAt,\n      endAt,\n      rate\n    })\n  });\n\n  return channel;\n};\n\nconst createWsChannel = async (fetch: fetchFn, resourceUri: string, options: CreateSolidChannelOptions) => {\n  const channel = await createSolidNotificationChannel(fetch, resourceUri, options);\n  const receiveFrom: string = channel.receiveFrom || channel['notify:receiveFrom'];\n\n  return new WebSocket(receiveFrom);\n};\n\nconst registeredWebSockets = new Map<string, WebSocket | Promise<WebSocket>>();\n\n/**\n * @param fetch A react admin fetch function.\n * @param resourceUri The resource to subscribe to\n * @param options Options to pass to @see createSolidNotificationChannel, if the channel does not exist yet.\n * @returns {WebSocket} A new or existing web socket that subscribed to the given resource.\n */\nconst getOrCreateWsChannel = async (\n  fetch: fetchFn,\n  resourceUri: string,\n  options: CreateSolidChannelOptions = { type: 'WebSocketChannel2023', closeAfter: 1000 * 60 * 60 }\n) => {\n  const socket = registeredWebSockets.get(resourceUri);\n  if (socket) {\n    // Will resolve or is resolved already.\n    return socket;\n  }\n\n  // Create a promise, to return immediately and set the sockets cache.\n  // This prevents racing conditions that create multiple channels.\n  const wsPromise = createWsChannel(fetch, resourceUri, { ...options, type: 'WebSocketChannel2023' }).then(ws => {\n    // Remove the promise from the cache, if it closes.\n    ws.addEventListener('close', e => {\n      registeredWebSockets.delete(resourceUri);\n    });\n    // Close the socket, if the endAt / closeAfter time is reached.\n    const closeIn = options.closeAfter ?? (options.endAt && new Date(options.endAt).getTime() - Date.now());\n    if (closeIn)\n      setTimeout(() => {\n        ws.close();\n      }, closeIn);\n\n    return ws;\n  });\n\n  registeredWebSockets.set(resourceUri, wsPromise);\n  return wsPromise;\n};\n\nexport { getOrCreateWsChannel, createWsChannel, createSolidNotificationChannel };\n","/* eslint-disable @typescript-eslint/no-redundant-type-constituents */\nimport { DataProvider as RaDataProvider, RaRecord, fetchUtils } from 'react-admin';\nimport type { Quad } from '@rdfjs/types';\n\nexport type DataServerKey = string & { readonly _type?: 'DataServerKey' };\nexport type ContainerURI = string & { readonly _type?: 'ContainerURI' };\n\ntype DataServerConfig = {\n  /** Server base url */\n  baseUrl: string;\n\n  /** Default server (used for the creation of resources) */\n  default?: boolean;\n\n  /** True if this is the server where users are autenticated */\n  authServer?: boolean;\n\n  /** True if we should fetch void endpoint */\n  void?: boolean;\n\n  /** True if the server is a pod */\n  pod?: boolean;\n\n  /** Container used for uploaded files */\n  uploadsContainer?: string;\n\n  proxyUrl?: string;\n  noProxy?: boolean;\n\n  externalLinks?: boolean;\n\n  // Server attributes that can be retrieved via void endpoint\n  name: string;\n  description: string;\n  sparqlEndpoint: string;\n  containers?: Record<DataServerKey, Record<string, string[]>>;\n  blankNodes: any; // TODO: Type this object\n};\n\nexport type DataServersConfig = Record<DataServerKey, DataServerConfig>;\n\ntype HttpClientOptions = {\n  headers?: Headers;\n  method?: 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE';\n  body?: string | File;\n};\n\nexport type DataModel = {\n  /** Type(s) of resources to fetch or create (example: [pair:Organization]) */\n  types: string | string[];\n  list?: {\n    /** The servers where to fetch the resource. Default to @all */\n    servers?: DataServerKey[] | DataServerKey | '@all' | '@remote' | '@default' | '@auth' | '@pod';\n\n    /** URL(s) of the container(s) to fetch. If specified, will bypass the list.servers config */\n    containers?: Record<DataServerKey, string[]>;\n\n    /** Predicates listed are blank nodes and will be dereferenced in SPARQL queries. Automatically set if Void endpoints are found */\n    blankNodes?: string[];\n\n    /** @deprecated Predicates listed will be turned to arrays if they are simple strings. Used by for reified relationship */\n    forceArray?: [];\n\n    /** Will only fetch the given predicates (and the @type) */\n    predicates?: string[];\n\n    /** React-Admin permanent filter applied to all requests */\n    filter?: Record<string, unknown>;\n\n    /** If true, the data provider will fetch the LDP containers instead of doing a SPARQL request */\n    fetchContainer?: boolean;\n\n    /** If false, improve performances by not including the @embed rule in post-request JSON-LD framing */\n    explicitEmbedOnFraming?: boolean;\n  };\n  create?: {\n    /** The server where to create new resources. Default to @default */\n    server?: '@default' | '@auth' | '@pod' | DataServerKey;\n\n    /** URL of the container where to create new resources. If specified, will bypass the create.server config */\n    container?: Record<DataServerKey, string>;\n  };\n  fieldsMapping?: {\n    /** The predicate of the title */\n    title: string;\n  };\n};\n\nexport type Configuration = {\n  dataServers: DataServersConfig;\n  httpClient: (url: string, options?: HttpClientOptions) => ReturnType<typeof fetchUtils.fetchJson>;\n\n  /** Context from ontologies { prefix: IRI } or IRI, or array of IRI */\n  jsonContext: string | string[] | Record<string, string>;\n\n  resources: Record<string, DataModel>;\n};\n\nexport type DataProvider = RaDataProvider & {\n  getDataModels: () => Promise<Record<string, DataModel>>;\n  getDataServers: () => Promise<DataServersConfig>;\n  fetch: (url: string, options?: HttpClientOptions) => ReturnType<typeof fetchUtils.fetchJson>;\n};\n\nexport interface PatchParams<RecordType extends RaRecord = any> {\n  id: RecordType['id'];\n  triplesToAdd?: Quad[];\n  triplesToRemove?: Quad[];\n}\n"],"names":[],"version":3,"file":"index.cjs.js.map"}