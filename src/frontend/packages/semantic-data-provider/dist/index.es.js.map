{"mappings":"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","sources":["packages/semantic-data-provider/src/index.ts","packages/semantic-data-provider/src/dataProvider/dataProvider.js","packages/semantic-data-provider/src/dataProvider/types.ts","packages/semantic-data-provider/src/dataProvider/methods/create.js","packages/semantic-data-provider/src/dataProvider/methods/getOne.js","packages/semantic-data-provider/src/dataProvider/utils/fetchResource.js","packages/semantic-data-provider/src/dataProvider/utils/handleFiles.ts","packages/semantic-data-provider/src/dataProvider/utils/findContainersWithTypes.ts","packages/semantic-data-provider/src/dataProvider/utils/parseServerKeys.ts","packages/semantic-data-provider/src/dataProvider/utils/getServerKeyFromType.js","packages/semantic-data-provider/src/dataProvider/utils/findContainersWithURIs.ts","packages/semantic-data-provider/src/dataProvider/methods/delete.ts","packages/semantic-data-provider/src/dataProvider/methods/deleteMany.js","packages/semantic-data-provider/src/dataProvider/methods/getDataServers.js","packages/semantic-data-provider/src/dataProvider/methods/getDataModels.js","packages/semantic-data-provider/src/dataProvider/methods/getList.ts","packages/semantic-data-provider/src/dataProvider/utils/fetchContainers.ts","packages/semantic-data-provider/src/dataProvider/utils/arrayOf.ts","packages/semantic-data-provider/src/dataProvider/utils/fetchSparqlEndpoints.js","packages/semantic-data-provider/src/dataProvider/utils/getEmbedFrame.js","packages/semantic-data-provider/src/dataProvider/utils/buildSparqlQuery.js","packages/semantic-data-provider/src/dataProvider/utils/buildBaseQuery.js","packages/semantic-data-provider/src/dataProvider/utils/getUriFromPrefix.ts","packages/semantic-data-provider/src/dataProvider/utils/buildBlankNodesQuery.js","packages/semantic-data-provider/src/dataProvider/utils/buildAutoDetectBlankNodesQuery.js","packages/semantic-data-provider/src/dataProvider/methods/getMany.js","packages/semantic-data-provider/src/dataProvider/methods/getManyReference.js","packages/semantic-data-provider/src/dataProvider/methods/patch.ts","packages/semantic-data-provider/src/dataProvider/methods/update.ts","packages/semantic-data-provider/src/dataProvider/utils/getServerKeyFromUri.js","packages/semantic-data-provider/src/dataProvider/httpClient.js","packages/semantic-data-provider/src/dataProvider/utils/normalizeConfig.ts","packages/semantic-data-provider/src/dataProvider/utils/expandTypes.ts","packages/semantic-data-provider/src/dataProvider/plugins/configureUserStorage.ts","packages/semantic-data-provider/src/dataProvider/plugins/fetchAppRegistration.ts","packages/semantic-data-provider/src/dataProvider/utils/getContainerFromDataRegistration.ts","packages/semantic-data-provider/src/dataProvider/plugins/fetchDataRegistry.ts","packages/semantic-data-provider/src/dataProvider/plugins/fetchTypeIndexes.ts","packages/semantic-data-provider/src/dataProvider/plugins/fetchVoidEndpoints.ts","packages/semantic-data-provider/src/hooks/useCompactPredicate.ts","packages/semantic-data-provider/src/hooks/useDataProviderConfig.ts","packages/semantic-data-provider/src/dataProvider/utils/compactPredicate.ts","packages/semantic-data-provider/src/hooks/useContainers.ts","packages/semantic-data-provider/src/hooks/useDataModels.ts","packages/semantic-data-provider/src/hooks/useDataServers.ts","packages/semantic-data-provider/src/hooks/useContainersByTypes.ts","packages/semantic-data-provider/src/hooks/useContainerByUri.ts","packages/semantic-data-provider/src/hooks/useCreateContainerUri.ts","packages/semantic-data-provider/src/hooks/useGetCreateContainerUri.ts","packages/semantic-data-provider/src/dataProvider/utils/findCreateContainerWithTypes.ts","packages/semantic-data-provider/src/hooks/useDataModel.ts","packages/semantic-data-provider/src/hooks/useGetExternalLink.js","packages/semantic-data-provider/src/hooks/useGetPrefixFromUri.ts","packages/semantic-data-provider/src/dataProvider/utils/getPrefixFromUri.ts","packages/semantic-data-provider/src/reification/FilterHandler.js","packages/semantic-data-provider/src/reification/GroupedReferenceHandler.js","packages/semantic-data-provider/src/reification/ReificationArrayInput.js","packages/semantic-data-provider/src/notificationChannels/subscribeToUpdates.ts"],"sourcesContent":["export { default as dataProvider } from './dataProvider/dataProvider';\n\nexport { default as buildSparqlQuery } from './dataProvider/utils/buildSparqlQuery';\nexport { default as buildBlankNodesQuery } from './dataProvider/utils/buildBlankNodesQuery';\n\nexport { default as configureUserStorage } from './dataProvider/plugins/configureUserStorage';\nexport { default as fetchAppRegistration } from './dataProvider/plugins/fetchAppRegistration';\nexport { default as fetchDataRegistry } from './dataProvider/plugins/fetchDataRegistry';\nexport { default as fetchTypeIndexes } from './dataProvider/plugins/fetchTypeIndexes';\nexport { default as fetchVoidEndpoints } from './dataProvider/plugins/fetchVoidEndpoints';\n\nexport { default as useCompactPredicate } from './hooks/useCompactPredicate';\nexport { default as useContainers } from './hooks/useContainers';\nexport { default as useContainersByTypes } from './hooks/useContainersByTypes';\nexport { default as useContainerByUri } from './hooks/useContainerByUri';\nexport { default as useCreateContainerUri } from './hooks/useCreateContainerUri';\nexport { default as useDataModel } from './hooks/useDataModel';\nexport { default as useDataModels } from './hooks/useDataModels';\nexport { default as useDataServers } from './hooks/useDataServers';\nexport { default as useGetCreateContainerUri } from './hooks/useGetCreateContainerUri';\nexport { default as useGetExternalLink } from './hooks/useGetExternalLink';\nexport { default as useGetPrefixFromUri } from './hooks/useGetPrefixFromUri';\n\nexport { default as FilterHandler } from './reification/FilterHandler';\nexport { default as GroupedReferenceHandler } from './reification/GroupedReferenceHandler';\nexport { default as ReificationArrayInput } from './reification/ReificationArrayInput';\n\nexport {\n  createWsChannel,\n  getOrCreateWsChannel,\n  createSolidNotificationChannel\n} from './notificationChannels/subscribeToUpdates';\n\nexport * from './dataProvider/types';\n","import { Configuration, SemanticDataProvider } from './types';\nimport createMethod from './methods/create';\nimport deleteMethod from './methods/delete';\nimport deleteManyMethod from './methods/deleteMany';\nimport getDataServersMethod from './methods/getDataServers';\nimport getDataModelsMethod from './methods/getDataModels';\nimport getListMethod from './methods/getList';\nimport getManyMethod from './methods/getMany';\nimport getManyReferenceMethod from './methods/getManyReference';\nimport getOneMethod from './methods/getOne';\nimport patchMethod from './methods/patch';\nimport updateMethod from './methods/update';\nimport httpClient from './httpClient';\nimport { uploadFile } from './utils/handleFiles';\nimport normalizeConfig from './utils/normalizeConfig';\nimport expandTypes from './utils/expandTypes';\n\n/** @type {(originalConfig: Configuration) => SemanticDataProvider} */\nconst dataProvider = originalConfig => {\n  // Keep in memory for refresh\n  let config = { ...originalConfig };\n\n  const prepareConfig = async () => {\n    // Configure httpClient with initial data servers, so that plugins may use it\n    config.httpClient = httpClient(config.dataServers);\n\n    for (const plugin of config.plugins) {\n      if (plugin.transformConfig) {\n        config = await plugin.transformConfig(config);\n      }\n    }\n\n    // Configure again httpClient with possibly updated data servers\n    config.httpClient = httpClient(config.dataServers);\n\n    if (!config.jsonContext) config.jsonContext = config.ontologies;\n    if (!config.returnFailedResources) config.returnFailedResources = false;\n\n    config = await normalizeConfig(config);\n\n    console.log('Config after plugins', config);\n  };\n\n  // Immediately call the preload plugins\n  const prepareConfigPromise = prepareConfig();\n\n  const waitForPrepareConfig =\n    method =>\n    async (...arg) => {\n      await prepareConfigPromise; // Return immediately if plugins have already been loaded\n      return method(config)(...arg);\n    };\n\n  return {\n    getList: waitForPrepareConfig(getListMethod),\n    getMany: waitForPrepareConfig(getManyMethod),\n    getManyReference: waitForPrepareConfig(getManyReferenceMethod),\n    getOne: waitForPrepareConfig(getOneMethod),\n    create: waitForPrepareConfig(createMethod),\n    update: waitForPrepareConfig(updateMethod),\n    updateMany: () => {\n      throw new Error('updateMany is not implemented yet');\n    },\n    delete: waitForPrepareConfig(deleteMethod),\n    deleteMany: waitForPrepareConfig(deleteManyMethod),\n    // Custom methods\n    patch: waitForPrepareConfig(patchMethod),\n    getDataModels: waitForPrepareConfig(getDataModelsMethod),\n    getDataServers: waitForPrepareConfig(getDataServersMethod),\n    getLocalDataServers: getDataServersMethod(originalConfig),\n    fetch: waitForPrepareConfig(c => httpClient(c.dataServers)),\n    uploadFile: waitForPrepareConfig(c => rawFile => uploadFile(rawFile, c)),\n    expandTypes: waitForPrepareConfig(c => types => expandTypes(types, c.jsonContext)),\n    getConfig: waitForPrepareConfig(c => () => c),\n    refreshConfig: async () => {\n      config = { ...originalConfig };\n      await prepareConfig();\n      return config;\n    }\n  };\n};\n\nexport default dataProvider;\n","/* eslint-disable @typescript-eslint/no-redundant-type-constituents */\nimport { DataProvider, RaRecord, fetchUtils } from 'react-admin';\nimport type { Quad } from '@rdfjs/types';\n\nexport type DataServerKey = string & { readonly _type?: 'DataServerKey' };\nexport type ContainerURI = string & { readonly _type?: 'ContainerURI' };\n\nexport type Container = {\n  server?: string;\n  uri?: string;\n  path: string;\n  types: string[];\n  [k: string]: any;\n};\n\ntype DataServerConfig = {\n  /** Server base url */\n  baseUrl: string;\n\n  /** Default server (used for the creation of resources) */\n  default?: boolean;\n\n  /** True if this is the server where users are autenticated */\n  authServer?: boolean;\n\n  /** True if the server is a pod */\n  pod?: boolean;\n\n  containers: Container[];\n\n  /** Container used for uploaded files */\n  uploadsContainer?: string;\n\n  sparqlEndpoint?: string;\n  proxyUrl?: string;\n  noProxy?: boolean;\n\n  externalLinks?: boolean;\n\n  // Server attributes that can be retrieved via void endpoint\n  name?: string;\n  description?: string;\n\n  blankNodes?: any; // TODO: Type this object\n\n  [k: string]: any;\n};\n\nexport type DataServersConfig = Record<DataServerKey, DataServerConfig>;\n\nexport type DataModel = {\n  /** Type(s) of resources to fetch or create (example: [pair:Organization]) */\n  types: string | string[];\n  /** Shape tree matching the data model. Can be used instead of types. */\n  shapeTreeUri?: string;\n  list?: {\n    /** The servers where to fetch the resource. Default to @all */\n    servers?: DataServerKey[] | DataServerKey | '@all' | '@remote' | '@default' | '@auth' | '@pod';\n\n    /** URL(s) of the container(s) to fetch. If specified, will bypass the list.servers config */\n    containers?: string[];\n\n    /** Predicates listed are blank nodes and will be dereferenced in SPARQL queries. Automatically set if Void endpoints are found */\n    blankNodes?: string[];\n\n    /** @deprecated Predicates listed will be turned to arrays if they are simple strings. Used by for reified relationship */\n    forceArray?: [];\n\n    /** Will only fetch the given predicates (and the @type) */\n    predicates?: string[];\n\n    /** React-Admin permanent filter applied to all requests */\n    filter?: Record<string, unknown>;\n\n    /** If true, the data provider will fetch the LDP containers instead of doing a SPARQL request */\n    fetchContainer?: boolean;\n\n    /** If false, improve performances by not including the @embed rule in post-request JSON-LD framing */\n    explicitEmbedOnFraming?: boolean;\n  };\n  create?: {\n    /** The server where to create new resources. Default to @default */\n    server?: '@default' | '@auth' | '@pod' | DataServerKey;\n\n    /** URL of the container where to create new resources. If specified, will bypass the create.server config */\n    container?: string[];\n  };\n  fieldsMapping?: {\n    /** The predicate of the title */\n    title: string;\n  };\n};\n\nexport type FetchFn = typeof fetchUtils.fetchJson;\n\nexport type Configuration = {\n  dataServers: DataServersConfig;\n  httpClient: FetchFn;\n\n  /** Context from ontologies { prefix: IRI } or IRI, or array of IRI */\n  jsonContext: string | string[] | Record<string, string>;\n\n  resources: Record<string, DataModel>;\n\n  ontologies: Record<string, string>;\n\n  plugins: Plugin[];\n};\n\nexport type Plugin = {\n  transformConfig: (config: Configuration) => Promise<Configuration>;\n};\n\nexport type SemanticDataProvider = DataProvider & {\n  getDataModels: () => Promise<Record<string, DataModel>>;\n  getDataServers: () => Promise<DataServersConfig>;\n  fetch: FetchFn;\n  getConfig: () => Promise<Configuration>;\n  refreshConfig: () => Promise<Configuration>;\n  uploadFile: (rawFile: File) => Promise<string | null>;\n  expandTypes: (types: string[]) => Promise<string[]>;\n};\n\nexport interface PatchParams<RecordType extends RaRecord = any> {\n  id: RecordType['id'];\n  triplesToAdd?: Quad[];\n  triplesToRemove?: Quad[];\n}\n\nexport interface ResponseError extends Error {\n  status?: number;\n}\n\nexport type VoidPartition = {\n  'void:class': string;\n  'void:entities': string;\n  'void:uriSpace': string;\n};\n\nexport type VoidDataset = {\n  '@id': string;\n  '@type': string;\n  'dc:description': string;\n  'dc:title': string;\n  'void:classPartition': VoidPartition[];\n  'void:features': string;\n  'void:rootResource': string;\n  'void:sparqlEndpoint': string;\n  'void:uriSpace': string;\n  'void:vocabulary': string[];\n};\n\nexport type VoidResults = {\n  key: string;\n  context?: any;\n  datasets?: VoidDataset[];\n  error?: string;\n};\n\nexport type TypeRegistration = {\n  id: string;\n  type: string;\n  'solid:forClass': string | string[];\n  'solid:instanceContainer': string;\n};\n","import createSlug from 'speakingurl';\nimport getOne from './getOne';\nimport handleFiles from '../utils/handleFiles';\nimport findContainersWithTypes from '../utils/findContainersWithTypes';\nimport findContainersWithURIs from '../utils/findContainersWithURIs';\n\nconst createMethod = config => async (resourceId, params) => {\n  const { dataServers, resources, httpClient, jsonContext } = config;\n  const dataModel = resources[resourceId];\n\n  if (!dataModel) Error(`Resource ${resourceId} is not mapped in resources file`);\n\n  const headers = new Headers();\n\n  let containerUri;\n  let serverKey;\n  if (dataModel.create?.container) {\n    const [container] = findContainersWithURIs([dataModel.create?.container], dataServers);\n    serverKey = container.server;\n    containerUri = container.uri;\n  } else {\n    serverKey = dataModel.create?.server || Object.keys(dataServers).find(key => dataServers[key].default === true);\n    if (!serverKey) throw new Error('You must define a server for the creation, or a container, or a default server');\n\n    const containers = findContainersWithTypes(dataModel.types, [serverKey], dataServers);\n\n    if (!containers || containers.length === 0)\n      throw new Error(`No container with types ${JSON.stringify(dataModel.types)} found on server ${serverKey}`);\n    if (containers.length > 1)\n      throw new Error(\n        `More than one container detected with types ${JSON.stringify(dataModel.types)} on server ${serverKey}`\n      );\n\n    containerUri = containers[0].uri;\n  }\n\n  if (params.data) {\n    if (dataModel.fieldsMapping?.title) {\n      const slug = Array.isArray(dataModel.fieldsMapping.title)\n        ? dataModel.fieldsMapping.title.map(f => params.data[f]).join(' ')\n        : params.data[dataModel.fieldsMapping.title];\n\n      // Generate slug here, otherwise we may get errors with special characters\n      headers.set('Slug', createSlug(slug));\n    }\n\n    // Upload files, if there are any\n    const { updatedRecord } = await handleFiles.upload(params.data, config, serverKey);\n    params.data = updatedRecord;\n\n    const { headers: responseHeaders } = await httpClient(containerUri, {\n      method: 'POST',\n      headers,\n      body: JSON.stringify({\n        '@context': jsonContext,\n        '@type': dataModel.types,\n        ...params.data\n      })\n    });\n\n    // Retrieve newly-created resource\n    const resourceUri = responseHeaders.get('Location');\n    return await getOne(config)(resourceId, { id: resourceUri });\n  }\n  if (params.id) {\n    headers.set('Content-Type', 'application/sparql-update');\n\n    await httpClient(containerUri, {\n      method: 'PATCH',\n      headers,\n      body: `\n        PREFIX ldp: <http://www.w3.org/ns/ldp#>\n        INSERT DATA { <${containerUri}> ldp:contains <${params.id}>. };\n      `\n    });\n\n    // Create must return the new data, so get them from the remote URI\n    return await getOne(config)(resourceId, { id: params.id });\n  }\n};\n\nexport default createMethod;\n","import fetchResource from '../utils/fetchResource';\n\nconst getOneMethod = config => async (resourceId, params) => {\n  const { resources } = config;\n  const dataModel = resources[resourceId];\n\n  if (!dataModel) throw new Error(`Resource ${resourceId} is not mapped in resources file`);\n\n  const data = await fetchResource(params.id, config);\n\n  // Transform single value into array if forceArray is set\n  if (dataModel.list?.forceArray) {\n    for (const forceArrayItem of dataModel.list?.forceArray || []) {\n      if (data[forceArrayItem] && !Array.isArray(data[forceArrayItem])) {\n        data[forceArrayItem] = [data[forceArrayItem]];\n      }\n    }\n  }\n\n  // TODO activate defaultFetchPlan option\n  // if (dataModel.list?.defaultFetchPlan) {\n  //   for (const node of dataModel.list?.defaultFetchPlan) {\n  //     if (\n  //       data[node] &&\n  //       typeof data[node] === 'string' &&\n  //       data[node].startsWith('http')\n  //     ) {\n  //       try {\n  //         const dataToEmbed = await fetchResource(data[node], config);\n  //         delete dataToEmbed['@context'];\n  //         data[node] = dataToEmbed;\n  //       } catch (e) {\n  //         // Ignore errors (this may happen if user does not have rights to see the resource)\n  //       }\n  //     }\n  //   }\n  // }\n\n  return { data };\n};\n\nexport default getOneMethod;\n","import jsonld from 'jsonld';\n\nconst fetchResource = async (resourceUri, config) => {\n  const { httpClient, jsonContext } = config;\n\n  let { json: data } = await httpClient(resourceUri);\n\n  if (!data) throw new Error(`Not a valid JSON: ${resourceUri}`);\n\n  data.id = data.id || data['@id'];\n\n  // We compact only if the context is different between the frontend and the middleware\n  // TODO deep compare if the context is an object\n  if (data['@context'] !== jsonContext) {\n    data = await jsonld.compact(data, jsonContext);\n  }\n\n  return data;\n};\n\nexport default fetchResource;\n","import urlJoin from 'url-join';\nimport { RaRecord } from 'react-admin';\nimport { Configuration } from '../types';\n\nconst isFile = (o: any): o is { rawFile: File } => o?.rawFile && o.rawFile instanceof File;\nconst isFileToDelete = (o: any): o is { fileToDelete: string } =>\n  o?.fileToDelete !== undefined && o?.fileToDelete !== null;\n\nconst getUploadsContainerUri = (config: Configuration, serverKey?: string) => {\n  // If no server key is defined, or if the server has no uploads container, find any server with a uploads container\n  if (!serverKey || !config.dataServers[serverKey].uploadsContainer)\n    serverKey = Object.keys(config.dataServers).find(key => config.dataServers[key].uploadsContainer);\n\n  if (serverKey) {\n    return urlJoin(config.dataServers[serverKey].baseUrl, config.dataServers[serverKey].uploadsContainer!);\n  } else {\n    // No server has an uploads container\n    return null;\n  }\n};\n\nexport const uploadFile = async (rawFile: File, config: Configuration, serverKey?: string) => {\n  const uploadsContainerUri = getUploadsContainerUri(config, serverKey);\n  if (!uploadsContainerUri) throw new Error(\"You must define an uploadsContainer in one of the server's configuration\");\n\n  const response = await config.httpClient(uploadsContainerUri, {\n    method: 'POST',\n    body: rawFile,\n    headers: new Headers({\n      'Content-Type': rawFile.type\n    })\n  });\n\n  if (response.status === 201) {\n    return response.headers.get('Location');\n  }\n  return null;\n};\n\nconst deleteFiles = async (filesToDelete: string[], config: Configuration) => {\n  return Promise.all(\n    filesToDelete.map(file =>\n      config.httpClient(file, {\n        method: 'DELETE'\n      })\n    )\n  );\n};\n\n/*\n * Look for raw files in the record data.\n * If there are any, upload them and replace the file by its URL.\n */\nconst uploadAllFiles = async (record: Partial<RaRecord>, config: Configuration, serverKey?: string) => {\n  const filesToDelete: string[] = [];\n  const updatedRecord = { ...record };\n\n  for (const property of Object.keys(record)) {\n    const value = record[property];\n    if (Array.isArray(value)) {\n      for (let i = 0; i < value.length; i++) {\n        const itemValue = value[i];\n        if (isFile(itemValue)) {\n          if (isFileToDelete(itemValue)) {\n            filesToDelete.push(itemValue.fileToDelete);\n          }\n          updatedRecord[property][i] = await uploadFile(itemValue.rawFile, config, serverKey);\n        } else if (isFileToDelete(itemValue)) {\n          filesToDelete.push(itemValue.fileToDelete);\n          updatedRecord[property][i] = null;\n        }\n      }\n    } else if (isFile(value)) {\n      if (isFileToDelete(value)) {\n        filesToDelete.push(value.fileToDelete);\n      }\n      updatedRecord[property] = await uploadFile(value.rawFile, config, serverKey);\n    } else if (isFileToDelete(value)) {\n      filesToDelete.push(value.fileToDelete);\n      updatedRecord[property] = null;\n    }\n  }\n\n  return {\n    updatedRecord,\n    filesToDelete\n  };\n};\n\nexport default {\n  upload: uploadAllFiles,\n  delete: deleteFiles\n};\n","import { DataServersConfig, Container } from '../types';\nimport parseServerKeys from './parseServerKeys';\n\n/**\n * Return all containers matching the given types\n */\nconst findContainersWithTypes = (\n  types: string[],\n  serverKeys: string | string[] | undefined,\n  dataServers: DataServersConfig\n) => {\n  const matchingContainers: Container[] = [];\n\n  const parsedServerKeys = parseServerKeys(serverKeys || '@all', dataServers);\n\n  Object.keys(dataServers).forEach(dataServerKey => {\n    if (parsedServerKeys.includes(dataServerKey)) {\n      dataServers[dataServerKey].containers?.forEach(container => {\n        if (container.types?.some(t => types.includes(t))) {\n          matchingContainers.push(container);\n        }\n      });\n    }\n  });\n\n  return matchingContainers;\n};\n\nexport default findContainersWithTypes;\n","import getServerKeyFromType from './getServerKeyFromType';\nimport { DataServersConfig } from '../types';\n\nconst parseServerKey = (serverKey: string, dataServers: DataServersConfig) => {\n  switch (serverKey) {\n    case '@default':\n      return getServerKeyFromType('default', dataServers);\n    case '@pod':\n      return getServerKeyFromType('pod', dataServers);\n    case '@authServer':\n      return getServerKeyFromType('authServer', dataServers);\n    default:\n      return serverKey;\n  }\n};\n\n// Return the list of servers keys in an array\n// parsing keywords like @all, @default, @pod and @authServer\nconst parseServerKeys = (serverKeys: string | string[], dataServers: DataServersConfig) => {\n  if (Array.isArray(serverKeys)) {\n    if (serverKeys.includes('@all')) {\n      return Object.keys(dataServers);\n    } else {\n      return serverKeys.map(serverKey => parseServerKey(serverKey, dataServers));\n    }\n  } else if (typeof serverKeys === 'string') {\n    if (serverKeys === '@all') {\n      return Object.keys(dataServers);\n    } else if (serverKeys === '@remote') {\n      const defaultServerKey = getServerKeyFromType('default', dataServers);\n      return Object.keys(dataServers).filter(serverKey => serverKey !== defaultServerKey);\n    } else {\n      return [parseServerKey(serverKeys, dataServers)];\n    }\n  } else {\n    throw new Error(`The parseServerKeys expect a list of server keys, or keywords`);\n  }\n};\n\nexport default parseServerKeys;\n","const getServerKeyFromType = (type, dataServers) => {\n  return Object.keys(dataServers).find(key => {\n    return dataServers[key][type];\n  });\n};\n\nexport default getServerKeyFromType;\n","import { DataServersConfig, Container } from '../types';\n\nconst findContainersWithURIs = (containersUris: string[], dataServers: DataServersConfig) => {\n  const matchingContainers: Container[] = [];\n\n  Object.keys(dataServers).forEach(serverKey => {\n    dataServers[serverKey].containers?.forEach(container => {\n      if (container.uri && containersUris.includes(container.uri)) {\n        matchingContainers.push(container);\n      }\n    });\n  });\n\n  return matchingContainers;\n};\n\nexport default findContainersWithURIs;\n","import { DeleteParams, RaRecord } from 'react-admin';\nimport { Configuration } from '../types';\nimport handleFiles from '../utils/handleFiles';\n\nconst deleteMethod = (config: Configuration) => async (resourceId: string, params: DeleteParams<RaRecord>) => {\n  const { httpClient } = config;\n\n  await httpClient(`${params.id}`, {\n    method: 'DELETE'\n  });\n\n  if (params.meta?.filesToDelete) {\n    await handleFiles.delete(params.meta.filesToDelete, config);\n  }\n\n  return { data: { id: params.id } };\n};\n\nexport default deleteMethod;\n","const deleteManyMethod = config => async (resourceId, params) => {\n  const { httpClient } = config;\n  const ids = [];\n\n  for (const id of params.ids) {\n    try {\n      await httpClient(id, {\n        method: 'DELETE'\n      });\n      ids.push(id);\n    } catch (e) {\n      // Do nothing if we fail to delete a resource\n    }\n  }\n\n  return { data: ids };\n};\n\nexport default deleteManyMethod;\n","const getDataServers = config => () => {\n  return config.dataServers;\n};\n\nexport default getDataServers;\n","const getDataModels = config => () => {\n  return config.resources;\n};\n\nexport default getDataModels;\n","import { GetListParams } from 'react-admin';\nimport findContainersWithTypes from '../utils/findContainersWithTypes';\nimport fetchContainers from '../utils/fetchContainers';\nimport fetchSparqlEndpoints from '../utils/fetchSparqlEndpoints';\nimport findContainersWithURIs from '../utils/findContainersWithURIs';\nimport { Configuration, Container } from '../types';\nimport arrayOf from '../utils/arrayOf';\n\nconst getListMethod = (config: Configuration) => async (resourceId: string, params: GetListParams) => {\n  const { dataServers, resources } = config;\n  const dataModel = resources[resourceId];\n\n  if (!dataModel) throw new Error(`Resource ${resourceId} is not mapped in resources file`);\n\n  let containers: Container[] = [];\n  if (!params.filter?._servers && dataModel.list?.containers) {\n    if (Array.isArray(dataModel.list?.containers))\n      throw new Error(\n        `The list.containers property of ${resourceId} dataModel must be of type object ({ serverKey: [containerUri] })`\n      );\n    // If containers are set explicitly, use them\n    containers = findContainersWithURIs(dataModel.list.containers, dataServers);\n  } else if (dataModel.shapeTreeUri) {\n    containers = findContainersWithTypes(\n      arrayOf(dataModel.shapeTreeUri),\n      params?.filter?._servers || dataModel.list?.servers,\n      dataServers\n    );\n  } else {\n    // Otherwise find the container URIs on the given servers (either in the filter or the data model)\n    containers = findContainersWithTypes(\n      arrayOf(dataModel.types),\n      params?.filter?._servers || dataModel.list?.servers,\n      dataServers\n    );\n  }\n\n  if (dataModel.list?.fetchContainer) {\n    return fetchContainers(containers, params, config);\n  } else {\n    return fetchSparqlEndpoints(containers, resourceId, params, config);\n  }\n};\n\nexport default getListMethod;\n","import jsonld, { ContextDefinition } from 'jsonld';\nimport { GetListParams } from 'react-admin';\nimport arrayOf from './arrayOf';\nimport { Configuration, Container, DataServerKey } from '../types';\n\ntype LDPContainerType = 'ldp:Container' | 'ldp:BasicContainer';\n\ninterface LDPContainerBase {\n  '@context': Configuration['jsonContext'];\n  id: string;\n  'ldp:contains': Record<string, any>[];\n}\n\ninterface LDPContainerWithType extends LDPContainerBase {\n  type: LDPContainerType | LDPContainerType[];\n}\n\ninterface LDPContainerWithAtType extends LDPContainerBase {\n  '@type': LDPContainerType | LDPContainerType[];\n}\n\ntype LDPContainer = LDPContainerWithType | LDPContainerWithAtType;\n\ntype LDPResource = {\n  '@context': Configuration['jsonContext'];\n  [key: string]: any;\n};\n\ntype ListFilters = Partial<{\n  q: string;\n  type: string;\n  _predicates: string[];\n  _servers: DataServerKey[];\n  [attribute: string]: any;\n}>;\n\nconst isValidLDPContainer = (container: LDPContainer) => {\n  const resourceType = (container as LDPContainerWithType).type || (container as LDPContainerWithAtType)['@type'];\n  return Array.isArray(resourceType) ? resourceType.includes('ldp:Container') : resourceType === 'ldp:Container';\n};\n\nconst isObject = (val: any) => {\n  return val != null && typeof val === 'object' && !Array.isArray(val);\n};\n\nconst fetchContainers = async (\n  containers: Container[],\n  params: GetListParams,\n  { httpClient, jsonContext }: Configuration\n) => {\n  const fetchPromises = containers.map(container =>\n    httpClient(container.uri)\n      .then(async ({ json }) => {\n        const jsonResponse: LDPContainer = json;\n\n        // If container's context is different, compact it to have an uniform result\n        // TODO deep compare if the context is an object\n        if (jsonResponse['@context'] !== jsonContext) {\n          return jsonld.compact(jsonResponse, jsonContext as ContextDefinition) as unknown as Promise<LDPContainer>;\n        }\n\n        return jsonResponse;\n      })\n      .then((json: LDPContainer) => {\n        if (!isValidLDPContainer(json)) {\n          throw new Error(`${container.uri} is not a LDP container`);\n        }\n\n        return arrayOf(json['ldp:contains']).map<LDPResource>(resource => ({\n          '@context': json['@context'],\n          ...resource\n        }));\n      })\n  );\n\n  // Fetch simultaneously all containers\n  const results = await Promise.all(fetchPromises);\n  let resources = results.flat();\n\n  resources = resources.map(resource => {\n    resource.id = resource.id || resource['@id'];\n    return resource;\n  });\n\n  // Apply filter to results\n  const filters: ListFilters = params.filter;\n\n  // For SPARQL queries, we use \"a\" to filter types, but in containers it must be \"type\"\n  if (filters.a) {\n    filters.type = filters.a;\n    delete filters.a;\n  }\n\n  // Filter resources attributes according to _predicates list\n  if (filters._predicates && Array.isArray(filters._predicates)) {\n    const predicates = filters._predicates;\n    const mandatoryAttributes = ['id'];\n\n    resources = resources.map(resource => {\n      return Object.keys(resource)\n        .filter(key => predicates.includes(key) || mandatoryAttributes.includes(key))\n        .reduce<LDPResource>(\n          (filteredResource, key) => {\n            filteredResource[key] = resource[key];\n            return filteredResource;\n          },\n          { '@context': [] }\n        );\n    });\n  }\n\n  if (Object.keys(filters).filter(f => !['_predicates', '_servers'].includes(f)).length > 0) {\n    resources = resources.filter(resource => {\n      // Full text filtering\n      if (filters.q) {\n        return Object.values(resource).some(attributeValue => {\n          if (!isObject(attributeValue)) {\n            const arrayValues = Array.isArray(attributeValue) ? attributeValue : [attributeValue];\n            return arrayValues.some(value => {\n              if (typeof value === 'string') {\n                return value.toLowerCase().normalize('NFD').includes(filters.q!.toLowerCase().normalize('NFD'));\n              }\n              return false;\n            });\n          }\n          return false;\n        });\n      }\n\n      // Attribute filtering\n      const attributesFilters = Object.keys(filters).filter(f => !['_predicates', '_servers', 'q'].includes(f));\n\n      return attributesFilters.every(attribute => {\n        if (resource[attribute]) {\n          const arrayValues: any[] = Array.isArray(resource[attribute]) ? resource[attribute] : [resource[attribute]];\n          return arrayValues.some(\n            (value: any) => typeof value === 'string' && value.includes(filters[attribute] as string)\n          );\n        }\n\n        return false;\n      });\n    });\n  }\n\n  // Sorting\n  if (params.sort) {\n    resources = resources.sort((a, b) => {\n      if (params.sort.order === 'ASC') {\n        return (a[params.sort.field] ?? '').localeCompare(b[params.sort.field] ?? '');\n      }\n      return (b[params.sort.field] ?? '').localeCompare(a[params.sort.field] ?? '');\n    });\n  }\n\n  // Pagination\n  const total = resources.length;\n\n  if (params.pagination) {\n    resources = resources.slice(\n      (params.pagination.page - 1) * params.pagination.perPage,\n      params.pagination.page * params.pagination.perPage\n    );\n  }\n\n  return { data: resources, total };\n};\n\nexport default fetchContainers;\n","const arrayOf = <T>(value: T | T[]): T[] => {\n  // If the field is null-ish, we suppose there are no values.\n  if (!value) {\n    return [];\n  }\n  // Return as is.\n  if (Array.isArray(value)) {\n    return value;\n  }\n  // Single value is made an array.\n  return [value];\n};\n\nexport default arrayOf;\n","import jsonld from 'jsonld';\nimport getEmbedFrame from './getEmbedFrame';\nimport buildSparqlQuery from './buildSparqlQuery';\n\nconst compare = (a, b) => {\n  switch (typeof a) {\n    case 'string':\n      return a.localeCompare(b);\n    case 'number':\n      return a - b;\n    default:\n      return 0;\n  }\n};\n\nconst fetchSparqlEndpoints = async (containers, resourceId, params, config) => {\n  const { dataServers, resources, httpClient, jsonContext, ontologies } = config;\n  const dataModel = resources[resourceId];\n\n  const serversToQuery = containers.reduce((acc, cur) => {\n    if (!acc.includes(cur.server)) acc.push(cur.server);\n    return acc;\n  }, []);\n\n  const sparqlQueryPromises = serversToQuery.map(\n    serverKey =>\n      new Promise((resolve, reject) => {\n        const blankNodes = params.filter?.blankNodes || dataModel.list?.blankNodes;\n\n        const sparqlQuery = buildSparqlQuery({\n          containersUris: containers.filter(c => c.server === serverKey).map(c => c.uri),\n          params,\n          dataModel,\n          ontologies\n        });\n\n        httpClient(dataServers[serverKey].sparqlEndpoint, {\n          method: 'POST',\n          body: sparqlQuery\n        })\n          .then(({ json }) => {\n            // If we declared the blank nodes to dereference, embed only those blank nodes\n            // This solve problems which can occur when same-type resources are embedded in other resources\n            // To increase performances, you can set explicitEmbedOnFraming to false (make sure the result is still OK)\n            const frame =\n              blankNodes && dataModel.list?.explicitEmbedOnFraming !== false\n                ? {\n                    '@context': jsonContext,\n                    '@type': dataModel.types,\n                    '@embed': '@never',\n                    ...getEmbedFrame(blankNodes)\n                  }\n                : {\n                    '@context': jsonContext,\n                    '@type': dataModel.types\n                  };\n\n            // omitGraph option force results to be in a @graph, even if we have a single result\n            return jsonld.frame(json, frame, { omitGraph: false });\n          })\n          .then(compactJson => {\n            if (compactJson['@id']) {\n              const { '@context': context, ...rest } = compactJson;\n              compactJson = {\n                '@context': context,\n                '@graph': [rest]\n              };\n            }\n            resolve(\n              compactJson['@graph']?.map(resource => ({ '@context': compactJson['@context'], ...resource })) || []\n            );\n          })\n          .catch(e => reject(e));\n      })\n  );\n\n  // Run simultaneous SPARQL queries\n  let results = await Promise.all(sparqlQueryPromises);\n\n  if (results.length === 0) {\n    return { data: [], total: 0 };\n  }\n  // Merge all results in one array\n  results = [].concat(...results);\n\n  // Add id in addition to @id, as this is what React-Admin expects\n  let returnData = results.map(item => {\n    item.id = item.id || item['@id'];\n    return item;\n  });\n\n  // TODO sort and paginate the results in the SPARQL query to improve performances\n  if (params.sort) {\n    returnData = returnData.sort((a, b) => {\n      if (a[params.sort.field] !== undefined && b[params.sort.field] !== undefined) {\n        if (params.sort.order === 'ASC') {\n          return compare(a[params.sort.field], b[params.sort.field]);\n        }\n        return compare(b[params.sort.field], a[params.sort.field]);\n      }\n      return 0;\n    });\n  }\n  if (params.pagination) {\n    returnData = returnData.slice(\n      (params.pagination.page - 1) * params.pagination.perPage,\n      params.pagination.page * params.pagination.perPage\n    );\n  }\n\n  return { data: returnData, total: results.length };\n};\n\nexport default fetchSparqlEndpoints;\n","const getEmbedFrame = blankNodes => {\n  let embedFrame = {};\n  let predicates;\n  if (blankNodes) {\n    for (const blankNode of blankNodes) {\n      if (blankNode.includes('/')) {\n        predicates = blankNode.split('/').reverse();\n      } else {\n        predicates = [blankNode];\n      }\n      embedFrame = {\n        ...embedFrame,\n        ...predicates.reduce(\n          (accumulator, predicate) => ({\n            [predicate]: {\n              '@embed': '@last',\n              ...accumulator\n            }\n          }),\n          {}\n        )\n      };\n    }\n    return embedFrame;\n  }\n};\n\nexport default getEmbedFrame;\n","import DataFactory from '@rdfjs/data-model';\nimport buildBaseQuery from './buildBaseQuery';\nimport buildBlankNodesQuery from './buildBlankNodesQuery';\nimport buildAutoDetectBlankNodesQuery from './buildAutoDetectBlankNodesQuery';\nimport getUriFromPrefix from './getUriFromPrefix';\n\nconst SparqlGenerator = require('sparqljs').Generator;\n\nconst { literal, namedNode, triple, variable } = DataFactory;\n\nconst generator = new SparqlGenerator({\n  /* prefixes, baseIRI, factory, sparqlStar */\n});\n\nconst reservedFilterKeys = ['q', 'sparqlWhere', 'blankNodes', 'blankNodesDepth', '_servers', '_predicates'];\n\nconst buildSparqlQuery = ({ containersUris, params, dataModel, ontologies }) => {\n  const blankNodes = params.filter?.blankNodes || dataModel.list?.blankNodes;\n  const predicates = params.filter?._predicates || dataModel.list?.predicates;\n  const blankNodesDepth = params.filter?.blankNodesDepth ?? dataModel.list?.blankNodesDepth ?? 2;\n  const filter = { ...dataModel.list?.filter, ...params.filter };\n  const baseQuery = buildBaseQuery(predicates, ontologies);\n\n  const sparqlJsParams = {\n    queryType: 'CONSTRUCT',\n    template: baseQuery.construct,\n    where: [],\n    type: 'query',\n    prefixes: ontologies\n  };\n\n  const containerWhere = [\n    {\n      type: 'values',\n      values: containersUris.map(containerUri => ({ '?containerUri': namedNode(containerUri) }))\n    },\n    triple(variable('containerUri'), namedNode('http://www.w3.org/ns/ldp#contains'), variable('s1')),\n    {\n      type: 'filter',\n      expression: {\n        type: 'operation',\n        operator: 'isiri',\n        args: [variable('s1')]\n      }\n    }\n  ];\n\n  let resourceWhere = [];\n\n  if (filter && Object.keys(filter).length > 0) {\n    /*\n      Example of usage :\n      {\n        \"sparqlWhere\": {\n          \"type\": \"bgp\",\n          \"triples\": [{\n            \"subject\": {\"termType\": \"Variable\", \"value\": \"s1\"},\n            \"predicate\": {\"termType\": \"NameNode\", \"value\": \"http://virtual-assembly.org/ontologies/pair#label\"},\n            \"object\": {\"termType\": \"Literal\", \"value\": \"My Organization\"}\n          }]\n        }\n      }\n    */\n    if (filter.sparqlWhere) {\n      // When the SPARQL request comes from the browser's URL, it is a JSON string that must be parsed\n      const sparqlWhere =\n        filter.sparqlWhere && (typeof filter.sparqlWhere === 'string' || filter.sparqlWhere instanceof String)\n          ? JSON.parse(decodeURIComponent(filter.sparqlWhere))\n          : filter.sparqlWhere;\n\n      if (Object.keys(sparqlWhere).length > 0) {\n        [].concat(sparqlWhere).forEach(sw => {\n          resourceWhere.push(sw);\n        });\n      }\n    }\n\n    if (filter.q && filter.q.length > 0) {\n      resourceWhere.push({\n        type: 'group',\n        patterns: [\n          {\n            queryType: 'SELECT',\n            variables: [variable('s1')],\n            where: [\n              triple(variable('s1'), variable('p1'), variable('o1')),\n              {\n                type: 'filter',\n                expression: {\n                  type: 'operation',\n                  operator: 'isliteral',\n                  args: [variable('o1')]\n                }\n              },\n              {\n                type: 'filter',\n                expression: {\n                  type: 'operation',\n                  operator: 'regex',\n                  args: [\n                    {\n                      type: 'operation',\n                      operator: 'lcase',\n                      args: [\n                        {\n                          type: 'operation',\n                          operator: 'str',\n                          args: [variable('o1')]\n                        }\n                      ]\n                    },\n                    literal(filter.q.toLowerCase(), '', namedNode('http://www.w3.org/2001/XMLSchema#string'))\n                  ]\n                }\n              }\n            ],\n            type: 'query'\n          }\n        ]\n      });\n    }\n\n    // Other filters\n    // SPARQL keyword a = filter based on the class of a resource (example => 'a': 'pair:OrganizationType')\n    // Other filters are based on a value (example => 'petr:hasAudience': 'http://localhost:3000/audiences/tout-public')\n    Object.entries(filter).forEach(([predicate, object]) => {\n      if (!reservedFilterKeys.includes(predicate)) {\n        resourceWhere.unshift(\n          triple(\n            variable('s1'),\n            namedNode(getUriFromPrefix(predicate, ontologies)),\n            namedNode(getUriFromPrefix(object, ontologies))\n          )\n        );\n      }\n    });\n  }\n\n  // Blank nodes\n  const blankNodesQuery = blankNodes\n    ? buildBlankNodesQuery(blankNodes, baseQuery, ontologies)\n    : buildAutoDetectBlankNodesQuery(blankNodesDepth, baseQuery);\n\n  if (blankNodesQuery && blankNodesQuery.construct) {\n    resourceWhere = resourceWhere.concat(blankNodesQuery.where);\n    sparqlJsParams.template = sparqlJsParams.template.concat(blankNodesQuery.construct);\n  } else {\n    resourceWhere.push(baseQuery.where);\n  }\n\n  sparqlJsParams.where.push(containerWhere, resourceWhere);\n\n  return generator.stringify(sparqlJsParams);\n};\n\nexport default buildSparqlQuery;\n","import { namedNode, triple, variable } from '@rdfjs/data-model';\nimport getUriFromPrefix from './getUriFromPrefix';\n\nconst defaultToArray = value => (!value ? [] : Array.isArray(value) ? value : [value]);\n\n// We need to always include the type or React-Admin will not work properly\nconst typeQuery = triple(\n  variable('s1'),\n  namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),\n  variable('type')\n);\n\nconst buildBaseQuery = (predicates, ontologies) => {\n  let baseTriples;\n  if (predicates) {\n    baseTriples = defaultToArray(predicates).map((predicate, i) =>\n      triple(variable('s1'), namedNode(getUriFromPrefix(predicate, ontologies)), variable(`o${i + 1}`))\n    );\n    return {\n      construct: [typeQuery, ...baseTriples],\n      where: [typeQuery, ...baseTriples.map(triple => ({ type: 'optional', patterns: [triple] }))]\n    };\n  }\n  baseTriples = [triple(variable('s1'), variable('p1'), variable('o1'))];\n  return {\n    construct: baseTriples,\n    where: baseTriples\n  };\n};\n\nexport default buildBaseQuery;\n","const getUriFromPrefix = (item: string, ontologies: Record<string, string>) => {\n  if (item.startsWith('http://') || item.startsWith('https://')) {\n    // Already resolved, return the URI\n    return item;\n  } else if (item === 'a') {\n    // Special case\n    return 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type';\n  } else {\n    const [prefix, value] = item.split(':');\n    if (value) {\n      if (ontologies[prefix]) {\n        return ontologies[prefix] + value;\n      } else {\n        throw new Error(`No ontology found with prefix ${prefix}`);\n      }\n    } else {\n      throw new Error(`The value \"${item}\" is not correct. It must include a prefix or be a full URI.`);\n    }\n  }\n};\n\nexport default getUriFromPrefix;\n","import md5 from 'crypto-js/md5';\nimport { namedNode, triple, variable } from '@rdfjs/data-model';\nimport getUriFromPrefix from './getUriFromPrefix';\n\n// Transform ['ont:predicate1/ont:predicate2'] to ['ont:predicate1', 'ont:predicate1/ont:predicate2']\nconst extractNodes = blankNodes => {\n  const nodes = [];\n  if (blankNodes) {\n    for (const predicate of blankNodes) {\n      if (predicate.includes('/')) {\n        const nodeNames = predicate.split('/');\n        for (let i = 1; i <= nodeNames.length; i++) {\n          nodes.push(nodeNames.slice(0, i).join('/'));\n        }\n      } else {\n        nodes.push(predicate);\n      }\n    }\n  }\n  return nodes;\n};\n\nconst generateSparqlVarName = node => md5(node);\n\nconst getParentNode = node => node.includes('/') && node.split('/')[0];\n\nconst getPredicate = node => (node.includes('/') ? node.split('/')[1] : node);\n\nconst buildUnionQuery = queries =>\n  queries.map(q => {\n    let triples = q.query;\n    const firstTriple = queries.find(q2 => q.parentNode === q2.node);\n    if (firstTriple !== undefined) {\n      triples = triples.concat(firstTriple.query[0]);\n    }\n    return {\n      type: 'bgp',\n      triples\n    };\n  });\n\nconst buildBlankNodesQuery = (blankNodes, baseQuery, ontologies) => {\n  const queries = [];\n  const nodes = extractNodes(blankNodes);\n\n  if (nodes && ontologies && ontologies.length > 0) {\n    for (const node of nodes) {\n      const parentNode = getParentNode(node);\n      const predicate = getPredicate(node);\n      const varName = generateSparqlVarName(node);\n      const parentVarName = parentNode ? generateSparqlVarName(parentNode) : '1';\n\n      const query = [\n        triple(\n          variable(`s${parentVarName}`),\n          namedNode(getUriFromPrefix(predicate, ontologies)),\n          variable(`s${varName}`)\n        ),\n        triple(variable(`s${varName}`), variable(`p${varName}`), variable(`o${varName}`))\n      ];\n\n      queries.push({\n        node,\n        parentNode,\n        query,\n        filter: '' // `FILTER(isBLANK(?s${varName})) .`\n      });\n    }\n\n    return {\n      construct: queries.length > 0 ? queries.map(q => q.query).reduce((pre, cur) => pre.concat(cur)) : null,\n      where: {\n        type: 'union',\n        patterns: [baseQuery.where, ...buildUnionQuery(queries)]\n      }\n    };\n  }\n  return {\n    construct: '',\n    where: ''\n  };\n};\n\nexport default buildBlankNodesQuery;\n","import { triple, variable } from '@rdfjs/data-model';\n\nconst buildAutoDetectBlankNodesQuery = (depth, baseQuery) => {\n  const construct = [...baseQuery.construct];\n  let where = {};\n  if (depth > 0) {\n    const whereQueries = [];\n    whereQueries.push([baseQuery.where]);\n    for (let i = 1; i <= depth; i++) {\n      construct.push(triple(variable(`o${i}`), variable(`p${i + 1}`), variable(`o${i + 1}`)));\n      whereQueries.push([\n        ...whereQueries[whereQueries.length - 1],\n        {\n          type: 'filter',\n          expression: {\n            type: 'operation',\n            operator: 'isblank',\n            args: [variable(`o${i}`)]\n          }\n        },\n        triple(variable(`o${i}`), variable(`p${i + 1}`), variable(`o${i + 1}`))\n      ]);\n    }\n    where = {\n      type: 'union',\n      patterns: whereQueries\n    };\n  } else if (depth === 0) {\n    where = baseQuery.where;\n  } else {\n    throw new Error('The depth of buildAutoDetectBlankNodesQuery should be 0 or more');\n  }\n\n  return { construct, where };\n};\n\nexport default buildAutoDetectBlankNodesQuery;\n","import getOne from './getOne';\n\nconst getManyMethod = config => async (resourceId, params) => {\n  const { returnFailedResources } = config;\n\n  let returnData = await Promise.all(\n    params.ids.map(id =>\n      getOne(config)(resourceId, { id: typeof id === 'object' ? id['@id'] : id })\n        .then(({ data }) => data)\n        .catch(() => {\n          // Catch if one resource fails to load\n          // Otherwise no references will be show if only one is missing\n          // See https://github.com/marmelab/react-admin/issues/5190\n          if (returnFailedResources) {\n            return { id, _error: true };\n          }\n          // Returning nothing\n        })\n    )\n  );\n\n  // We don't want undefined results to appear in the results as it will break with react-admin\n  returnData = returnData.filter(e => e);\n\n  return { data: returnData };\n};\n\nexport default getManyMethod;\n","import getList from './getList';\n\nconst getManyReferenceMethod = config => async (resourceId, params) => {\n  params.filter = { ...params.filter, [params.target]: params.id };\n  delete params.target;\n  return await getList(config)(resourceId, params);\n};\n\nexport default getManyReferenceMethod;\n","import { RaRecord } from 'react-admin';\nimport { Generator as SparqlGenerator, Update } from 'sparqljs';\nimport { Configuration, PatchParams } from '../types';\n\nconst generator = new SparqlGenerator();\n\nconst patchMethod = (config: Configuration) => async (resourceId: string, params: PatchParams<RaRecord>) => {\n  const { httpClient } = config;\n\n  const sparqlUpdate = {\n    type: 'update',\n    prefixes: {},\n    updates: []\n  } as Update;\n\n  if (params.triplesToAdd) {\n    sparqlUpdate.updates.push({\n      updateType: 'insert',\n      insert: [{ type: 'bgp', triples: params.triplesToAdd }]\n    });\n  }\n\n  if (params.triplesToRemove) {\n    sparqlUpdate.updates.push({\n      updateType: 'delete',\n      delete: [{ type: 'bgp', triples: params.triplesToRemove }]\n    });\n  }\n\n  await httpClient(`${params.id}`, {\n    method: 'PATCH',\n    headers: new Headers({\n      'Content-Type': 'application/sparql-update'\n    }),\n    body: generator.stringify(sparqlUpdate)\n  });\n};\n\nexport default patchMethod;\n","import { RaRecord, UpdateParams } from 'react-admin';\nimport { Configuration } from '../types';\nimport handleFiles from '../utils/handleFiles';\nimport getServerKeyFromUri from '../utils/getServerKeyFromUri';\n\nconst updateMethod = (config: Configuration) => async (resourceId: string, params: UpdateParams<RaRecord>) => {\n  const { httpClient, jsonContext, dataServers } = config;\n\n  const serverKey = getServerKeyFromUri(params.id, dataServers);\n\n  // Upload files, if there are any\n  const { updatedRecord, filesToDelete } = await handleFiles.upload(params.data, config, serverKey);\n  params.data = updatedRecord;\n\n  await httpClient(`${params.id}`, {\n    method: 'PUT',\n    body: JSON.stringify({\n      '@context': jsonContext,\n      ...params.data\n    })\n  });\n\n  // Delete files only if update is successful\n  await handleFiles.delete(filesToDelete, config);\n\n  return { data: params.data };\n};\n\nexport default updateMethod;\n","// Return the first server matching with the baseUrl\nconst getServerKeyFromUri = (uri, dataServers) => {\n  if (!uri) throw Error(`No URI provided to getServerKeyFromUri`);\n  return Object.keys(dataServers).find(key => {\n    if (dataServers[key].pod) {\n      // The baseUrl ends with /data so remove this part to match with the webId and webId-related URLs (/inbox, /outbox...)\n      return dataServers[key].baseUrl && uri.startsWith(dataServers[key].baseUrl.replace('/data', ''));\n    }\n    return uri.startsWith(dataServers[key].baseUrl);\n  });\n};\n\nexport default getServerKeyFromUri;\n","import { fetchUtils } from 'react-admin';\nimport getServerKeyFromUri from './utils/getServerKeyFromUri';\nimport getServerKeyFromType from './utils/getServerKeyFromType';\n\n/*\n * HTTP client used by all calls in data provider and auth provider\n * Do proxy calls if a proxy endpoint is available and the server is different from the auth server\n */\nconst httpClient =\n  dataServers =>\n  (url, options = {}) => {\n    if (!url) throw new Error(`No URL provided on httpClient call`);\n\n    const authServerKey = getServerKeyFromType('authServer', dataServers);\n    const serverKey = getServerKeyFromUri(url, dataServers);\n    const useProxy =\n      serverKey !== authServerKey && dataServers[authServerKey]?.proxyUrl && dataServers[serverKey]?.noProxy !== true;\n\n    if (!options.headers) options.headers = new Headers();\n\n    switch (options.method) {\n      case 'POST':\n      case 'PATCH':\n      case 'PUT':\n        if (!options.headers.has('Accept')) options.headers.set('Accept', 'application/ld+json');\n        if (!options.headers.has('Content-Type')) options.headers.set('Content-Type', 'application/ld+json');\n        break;\n\n      case 'DELETE':\n        break;\n\n      case 'GET':\n      default:\n        if (!options.headers.has('Accept')) options.headers.set('Accept', 'application/ld+json');\n        break;\n    }\n\n    if (useProxy) {\n      const formData = new FormData();\n\n      formData.append('id', url);\n      formData.append('method', options.method || 'GET');\n      formData.append('headers', JSON.stringify(Object.fromEntries(options.headers.entries())));\n\n      if (options.body) {\n        if (options.body instanceof File) {\n          formData.append('body', options.body, options.body.name);\n        } else {\n          formData.append('body', options.body);\n        }\n      }\n\n      // Post to proxy endpoint with multipart/form-data format\n      return fetchUtils.fetchJson(dataServers[authServerKey].proxyUrl, {\n        method: 'POST',\n        headers: new Headers({\n          Authorization: `Bearer ${localStorage.getItem('token')}`\n        }),\n        body: formData\n      });\n    }\n    // Add token if the server is the same as the auth server\n    if (serverKey === authServerKey) {\n      const token = localStorage.getItem('token');\n      if (token) options.headers.set('Authorization', `Bearer ${token}`);\n    }\n    return fetchUtils.fetchJson(url, options);\n  };\n\nexport default httpClient;\n","import urlJoin from 'url-join';\nimport { Configuration } from '../types';\nimport arrayOf from './arrayOf';\nimport expandTypes from './expandTypes';\n\nconst normalizeConfig = async (config: Configuration) => {\n  const newConfig: Configuration = { ...config };\n\n  // Add server and uri key to servers' containers\n  Object.keys(newConfig.dataServers).forEach(serverKey => {\n    newConfig.dataServers[serverKey].containers = newConfig.dataServers[serverKey].containers?.map(container => ({\n      ...container,\n      server: serverKey,\n      uri: urlJoin(config.dataServers[serverKey].baseUrl, container.path)\n    }));\n  });\n\n  // Expand types in data models\n  for (const resourceId of Object.keys(newConfig.resources)) {\n    newConfig.resources[resourceId].types = await expandTypes(\n      arrayOf(newConfig.resources[resourceId].types),\n      config.jsonContext\n    );\n  }\n\n  return newConfig;\n};\n\nexport default normalizeConfig;\n","import jsonld from 'jsonld';\nimport arrayOf from './arrayOf';\n\nconst isURL = (value: any) => (typeof value === 'string' || value instanceof String) && value.startsWith('http');\n\nconst expandTypes = async (types: string[], context: any): Promise<string[]> => {\n  // If types are already full URIs, return them immediately\n  if (types.every(type => isURL(type))) return types;\n\n  const result = await jsonld.expand({ '@context': context, '@type': types });\n\n  const expandedTypes = arrayOf<string>(result[0]['@type']!);\n\n  if (!expandedTypes.every(type => isURL(type))) {\n    throw new Error(`\n      Could not expand all types (${expandedTypes.join(', ')}).\n      Is an ontology missing or not registered yet on the local context ?\n    `);\n  }\n\n  return expandedTypes;\n};\n\nexport default expandTypes;\n","import jwtDecode from 'jwt-decode';\nimport urlJoin from 'url-join';\nimport { Configuration, Plugin } from '../types';\nimport { ContextDefinition } from 'jsonld';\n\nconst configureUserStorage = (): Plugin => ({\n  transformConfig: async (config: Configuration) => {\n    const token = localStorage.getItem('token');\n\n    // If the user is logged in\n    if (token) {\n      const payload: { [k: string]: string | number } = jwtDecode(token);\n      const webId = (payload.webId as string) || (payload.webid as string); // Currently we must deal with both formats\n      const { json: user } = await config.httpClient(webId);\n\n      if (user) {\n        const newConfig = { ...config } as Configuration;\n\n        newConfig.dataServers.user = {\n          pod: true,\n          default: true,\n          baseUrl: user['pim:storage'] || urlJoin(webId, 'data'),\n          sparqlEndpoint: user.endpoints?.['void:sparqlEndpoint'] || urlJoin(webId, 'sparql'),\n          proxyUrl: user.endpoints?.proxyUrl,\n          containers: []\n        };\n\n        newConfig.jsonContext = [\n          'https://www.w3.org/ns/activitystreams',\n          urlJoin(new URL(webId).origin, '/.well-known/context.jsonld')\n        ];\n\n        return newConfig;\n      }\n    }\n\n    // Nothing to change\n    return config;\n  }\n});\n\nexport default configureUserStorage;\n","import jwtDecode from 'jwt-decode';\nimport LinkHeader from 'http-link-header';\nimport { Configuration, Plugin } from '../types';\nimport arrayOf from '../utils/arrayOf';\nimport getContainerFromDataRegistration from '../utils/getContainerFromDataRegistration';\n\n/**\n * Return a function that look if an app (clientId) is registered with an user (webId)\n * If not, it redirects to the endpoint provided by the user's authorization agent\n * See https://solid.github.io/data-interoperability-panel/specification/#authorization-agent\n */\nconst fetchAppRegistration = (): Plugin => ({\n  transformConfig: async (config: Configuration) => {\n    const token = localStorage.getItem('token');\n\n    // If the user is logged in\n    if (token) {\n      const payload: { [k: string]: string | number } = jwtDecode(token);\n      const webId = (payload.webId as string) || (payload.webid as string); // Currently we must deal with both formats\n\n      const { json: user } = await config.httpClient(webId);\n      const authAgentUri = user['interop:hasAuthorizationAgent'];\n\n      if (authAgentUri) {\n        // Find if an application registration is linked to this user\n        // See https://solid.github.io/data-interoperability-panel/specification/#agent-registration-discovery\n        const { headers } = await config.httpClient(authAgentUri);\n        if (headers.has('Link')) {\n          const linkHeader = LinkHeader.parse(headers.get('Link')!);\n          const registeredAgentLinkHeader = linkHeader.rel('http://www.w3.org/ns/solid/interop#registeredAgent');\n\n          if (registeredAgentLinkHeader.length > 0) {\n            const appRegistrationUri = registeredAgentLinkHeader[0].anchor;\n            const { json: appRegistration } = await config.httpClient(appRegistrationUri);\n\n            const newConfig = { ...config } as Configuration;\n\n            for (const accessGrantUri of arrayOf(appRegistration['hasAccessGrant:hasDataGrant'])) {\n              const { json: accessGrant } = await config.httpClient(accessGrantUri);\n\n              for (const dataGrantUri of arrayOf(accessGrant['interop:hasDataGrant'])) {\n                const { json: dataGrant } = await config.httpClient(dataGrantUri);\n\n                const container = await getContainerFromDataRegistration(\n                  dataGrant['interop:hasDataRegistration'],\n                  config\n                );\n\n                newConfig.dataServers.user.containers?.push(container);\n              }\n            }\n\n            return newConfig;\n          }\n        }\n      }\n    }\n\n    return config;\n  }\n});\n\nexport default fetchAppRegistration;\n","import jsonld from 'jsonld';\nimport ShexParser from '@shexjs/parser';\nimport { Configuration, Container } from '../types';\n\nconst shexParser = ShexParser.construct('');\n\nconst getContainerFromDataRegistration = async (dataRegistrationUri: string, config: Configuration) => {\n  const { json: dataRegistration } = await config.httpClient(dataRegistrationUri, {\n    headers: new Headers({\n      Accept: 'application/ld+json',\n      Prefer: 'return=representation; include=\"http://www.w3.org/ns/ldp#PreferMinimalContainer\"'\n    })\n  });\n\n  const shapeTreeUri = dataRegistration['interop:registeredShapeTree'];\n\n  let { json: shapeTree } = await config.httpClient(shapeTreeUri);\n\n  shapeTree = await jsonld.compact(shapeTree, {\n    st: 'http://www.w3.org/ns/shapetrees#',\n    skos: 'http://www.w3.org/2004/02/skos/core#',\n    expectsType: { '@id': 'st:expectsType', '@type': '@id' },\n    shape: { '@id': 'st:shape', '@type': '@id' },\n    describesInstance: { '@id': 'st:describesInstance', '@type': '@id' },\n    label: { '@id': 'skos:prefLabel', '@container': '@language' }\n  });\n\n  const { baseUrl } = config.dataServers.user;\n  const containerPath = dataRegistration.id.replace(baseUrl, '');\n\n  const container = {\n    path: containerPath,\n    shapeTreeUri: shapeTree.shape,\n    label: shapeTree.label,\n    labelPredicate: shapeTree.describesInstance\n  };\n\n  if (shapeTree.shape) {\n    const { body: shexC } = await config.httpClient(shapeTree.shape, { headers: new Headers({ Accept: '*/*' }) }); // TODO use text/shex\n\n    const shexJ = shexParser.parse(shexC);\n\n    const type = shexJ?.shapes?.[0]?.shapeExpr?.expression?.expressions.find(\n      expr => expr.predicate === 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type'\n    )?.valueExpr?.values?.[0];\n\n    container.types = [type];\n  }\n\n  return container;\n};\n\nexport default getContainerFromDataRegistration;\n","import jwtDecode from 'jwt-decode';\nimport { Configuration, Plugin } from '../types';\nimport getContainerFromDataRegistration from '../utils/getContainerFromDataRegistration';\n\nconst fetchDataRegistry = (): Plugin => ({\n  transformConfig: async (config: Configuration) => {\n    const token = localStorage.getItem('token');\n\n    // If the user is logged in\n    if (token) {\n      if (!config.dataServers.user)\n        throw new Error(`You must configure the user storage first with the configureUserStorage plugin`);\n\n      const payload: { [k: string]: string | number } = jwtDecode(token);\n      const webId = (payload.webId as string) || (payload.webid as string); // Currently we must deal with both formats\n      const { json: user } = await config.httpClient(webId);\n      const { json: registrySet } = await config.httpClient(user['interop:hasRegistrySet']);\n      const { json: dataRegistry } = await config.httpClient(registrySet['interop:hasDataRegistry']);\n\n      if (dataRegistry['interop:hasDataRegistration']) {\n        const results = await Promise.all(\n          dataRegistry['interop:hasDataRegistration'].map((dataRegistrationUri: string) => {\n            return getContainerFromDataRegistration(dataRegistrationUri, config);\n          })\n        );\n\n        const newConfig = { ...config } as Configuration;\n        newConfig.dataServers.user.containers?.push(...results.flat());\n        return newConfig;\n      }\n    }\n\n    // Nothing to change\n    return config;\n  }\n});\n\nexport default fetchDataRegistry;\n","import jwtDecode from 'jwt-decode';\nimport { capitalCase } from 'change-case';\nimport { Configuration, Plugin, TypeRegistration } from '../types';\nimport arrayOf from '../utils/arrayOf';\nimport expandTypes from '../utils/expandTypes';\n\nconst fetchTypeIndexes = (): Plugin => ({\n  transformConfig: async (config: Configuration) => {\n    const token = localStorage.getItem('token');\n\n    // If the user is logged in\n    if (token) {\n      if (!config.dataServers.user)\n        throw new Error(`You must configure the user storage first with the configureUserStorage plugin`);\n\n      const payload: { [k: string]: string | number } = jwtDecode(token);\n      const webId = (payload.webId as string) || (payload.webid as string); // Currently we must deal with both formats\n      const { json: user } = await config.httpClient(webId);\n\n      const typeRegistrations: { public: TypeRegistration[]; private: TypeRegistration[] } = {\n        public: [],\n        private: []\n      };\n\n      if (user['solid:publicTypeIndex']) {\n        const { json: publicTypeIndex } = await config.httpClient(user['solid:publicTypeIndex']);\n        if (publicTypeIndex) {\n          typeRegistrations.public = arrayOf(publicTypeIndex['solid:hasTypeRegistration']);\n        }\n      }\n\n      if (user['pim:preferencesFile']) {\n        const { json: preferencesFile } = await config.httpClient(user['pim:preferencesFile']);\n        if (preferencesFile?.['solid:privateTypeIndex']) {\n          const { json: privateTypeIndex } = await config.httpClient(preferencesFile['solid:privateTypeIndex']);\n          typeRegistrations.private = arrayOf(privateTypeIndex['solid:hasTypeRegistration']);\n        }\n      }\n\n      if (typeRegistrations.public.length > 0 || typeRegistrations.private.length > 0) {\n        const newConfig = { ...config } as Configuration;\n\n        for (const mode of Object.keys(typeRegistrations)) {\n          for (const typeRegistration of typeRegistrations[mode as keyof typeof typeRegistrations]) {\n            const types = arrayOf(typeRegistration['solid:forClass']);\n            const container = {\n              label: { en: capitalCase(types[0].split(':')[1], { separateNumbers: true }) },\n              path: typeRegistration['solid:instanceContainer'].replace(newConfig.dataServers.user.baseUrl, ''),\n              types: await expandTypes(types, user['@context']),\n              private: mode === 'private'\n            };\n\n            const containerIndex = newConfig.dataServers.user.containers.findIndex(c => c.path === container.path);\n\n            if (containerIndex !== -1) {\n              // If a container with this URI already exist, add type registration information if they are not set\n              newConfig.dataServers.user.containers[containerIndex] = {\n                ...container,\n                ...newConfig.dataServers.user.containers[containerIndex]\n              };\n            } else {\n              newConfig.dataServers.user.containers.push(container);\n            }\n          }\n        }\n\n        return newConfig;\n      }\n    }\n\n    return config;\n  }\n});\n\nexport default fetchTypeIndexes;\n","import { Configuration, VoidResults, VoidDataset, ResponseError, Plugin } from '../types';\nimport arrayOf from '../utils/arrayOf';\nimport expandTypes from '../utils/expandTypes';\n\nconst fetchVoidEndpoints = (): Plugin => ({\n  transformConfig: async (config: Configuration) => {\n    let results = [] as VoidResults[];\n\n    try {\n      results = await Promise.all(\n        Object.entries(config.dataServers)\n          .filter(([_, server]) => server.pod !== true && server.void !== false)\n          .map(async ([key, server]) =>\n            config\n              .httpClient(new URL('/.well-known/void', server.baseUrl).toString())\n              .then(result => ({\n                key,\n                context: result.json?.['@context'],\n                datasets: result.json?.['@graph'] as VoidDataset[]\n              }))\n              .catch((e: ResponseError) => {\n                if (e.status === 404 || e.status === 401 || e.status === 500) {\n                  return { key, error: e.message };\n                }\n                throw e;\n              })\n          )\n      );\n    } catch (e) {\n      // Do not throw error if no endpoint found\n    }\n\n    results = results.filter(result => result.datasets);\n\n    if (results.length > 0) {\n      const newConfig = { ...config } as Configuration;\n\n      for (const result of results) {\n        // Ignore unfetchable endpoints\n        if (result.datasets) {\n          for (const dataset of result.datasets) {\n            newConfig.dataServers[result.key].name ??= dataset['dc:title'];\n            newConfig.dataServers[result.key].description ??= dataset['dc:description'];\n            newConfig.dataServers[result.key].sparqlEndpoint ??= dataset['void:sparqlEndpoint'];\n            newConfig.dataServers[result.key].containers ??= [];\n\n            for (const partition of arrayOf(dataset['void:classPartition'])) {\n              for (const type of arrayOf(partition['void:class'])) {\n                const path = partition['void:uriSpace'].replace(dataset['void:uriSpace'], '/');\n                const expandedTypes = await expandTypes([type], result.context);\n\n                const containerIndex = newConfig.dataServers[result.key].containers.findIndex(c =>\n                  c.types.some(t => expandedTypes.includes(t))\n                );\n                if (containerIndex && containerIndex !== -1) {\n                  // If a container with this type already exist, overwrite path and types\n                  newConfig.dataServers[result.key].containers[containerIndex] = {\n                    ...newConfig.dataServers[result.key].containers[containerIndex],\n                    path,\n                    types: expandedTypes\n                  };\n                } else {\n                  newConfig.dataServers[result.key].containers.push({\n                    path,\n                    types: expandedTypes\n                  });\n                }\n              }\n            }\n          }\n        }\n      }\n\n      return newConfig;\n    } else {\n      return config;\n    }\n  }\n});\n\nexport default fetchVoidEndpoints;\n","import { useEffect, useState } from 'react';\nimport { ContextDefinition } from 'jsonld';\nimport useDataProviderConfig from './useDataProviderConfig';\nimport compactPredicate from '../dataProvider/utils/compactPredicate';\n\nconst useCompactPredicate = (predicate: string, context?: ContextDefinition): string | undefined => {\n  const config = useDataProviderConfig();\n  const [result, setResult] = useState<string>();\n\n  useEffect(() => {\n    if (config && predicate) {\n      compactPredicate(predicate, context || config.jsonContext).then(r => {\n        setResult(r);\n      });\n    }\n  }, [predicate, setResult, config, context]);\n\n  return result;\n};\n\nexport default useCompactPredicate;\n","import { useState, useEffect } from 'react';\nimport { useDataProvider } from 'react-admin';\nimport { Configuration, SemanticDataProvider } from '../dataProvider/types';\n\nconst useDataProviderConfig = (): Configuration | undefined => {\n  const dataProvider = useDataProvider<SemanticDataProvider>();\n  const [config, setConfig] = useState<Configuration>();\n  const [isLoading, setIsLoading] = useState(false);\n\n  useEffect(() => {\n    if (!isLoading && !config) {\n      setIsLoading(true);\n      dataProvider.getConfig().then(c => {\n        setConfig(c);\n        setIsLoading(false);\n      });\n    }\n  }, [dataProvider, setConfig, config, setIsLoading, isLoading]);\n\n  return config;\n};\n\nexport default useDataProviderConfig;\n","import jsonld, { ContextDefinition } from 'jsonld';\n\nconst compactPredicate = async (predicate: string, context: ContextDefinition): Promise<string> => {\n  const result = await jsonld.compact({ [predicate]: '' }, context);\n\n  return Object.keys(result).find(key => key !== '@context')!;\n};\n\nexport default compactPredicate;\n","import { useEffect, useState } from 'react';\nimport useDataModels from './useDataModels';\nimport useDataServers from './useDataServers';\nimport findContainersWithTypes from '../dataProvider/utils/findContainersWithTypes';\nimport parseServerKeys from '../dataProvider/utils/parseServerKeys';\nimport { Container } from '../dataProvider/types';\nimport arrayOf from '../dataProvider/utils/arrayOf';\n\nconst useContainers = (resourceId?: string, serverKeys?: string | string[]) => {\n  const dataModels = useDataModels();\n  const dataServers = useDataServers();\n  const [containers, setContainers] = useState<Container[]>([]);\n\n  // Warning: if serverKeys change, the containers list will not be updated (otherwise we have an infinite re-render loop)\n  useEffect(() => {\n    if (dataServers && dataModels) {\n      if (resourceId) {\n        const dataModel = dataModels[resourceId];\n        setContainers(findContainersWithTypes(arrayOf(dataModel.types), serverKeys, dataServers));\n      } else {\n        const parsedServerKeys = parseServerKeys(serverKeys || '@all', dataServers) as string[];\n        setContainers(parsedServerKeys.map(serverKey => dataServers[serverKey].containers).flat());\n      }\n    }\n  }, [dataModels, dataServers, setContainers, resourceId]);\n\n  return containers;\n};\n\nexport default useContainers;\n","import useDataProviderConfig from './useDataProviderConfig';\n\nconst useDataModels = () => {\n  const config = useDataProviderConfig();\n  return config?.resources;\n};\n\nexport default useDataModels;\n","import useDataProviderConfig from './useDataProviderConfig';\n\nconst useDataServers = () => {\n  const config = useDataProviderConfig();\n  return config?.dataServers;\n};\n\nexport default useDataServers;\n","import { useEffect, useState } from 'react';\nimport { useDataProvider } from 'react-admin';\nimport useDataServers from './useDataServers';\nimport findContainersWithTypes from '../dataProvider/utils/findContainersWithTypes';\nimport { Container, SemanticDataProvider } from '../dataProvider/types';\nimport arrayOf from '../dataProvider/utils/arrayOf';\n\nconst useContainersByTypes = (types?: string | string[]) => {\n  const dataServers = useDataServers();\n  const dataProvider = useDataProvider<SemanticDataProvider>();\n  const [containers, setContainers] = useState<Container[]>([]);\n\n  useEffect(() => {\n    if (dataServers && types) {\n      dataProvider\n        .expandTypes(arrayOf(types))\n        .then(expandedTypes => {\n          setContainers(findContainersWithTypes(expandedTypes, '@all', dataServers));\n        })\n        .catch(() => {\n          // Ignore errors\n        });\n    }\n  }, [dataServers, dataProvider, setContainers, types]);\n\n  return containers;\n};\n\nexport default useContainersByTypes;\n","import { useEffect, useState } from 'react';\nimport useDataServers from './useDataServers';\nimport { Container } from '../dataProvider/types';\n\nconst useContainerByUri = (containerUri: string) => {\n  const dataServers = useDataServers();\n  const [container, setContainer] = useState<Container>();\n\n  useEffect(() => {\n    if (dataServers && containerUri) {\n      Object.keys(dataServers).forEach(serverKey => {\n        dataServers[serverKey].containers?.forEach(c => {\n          if (c.uri === containerUri) {\n            setContainer(c);\n          }\n        });\n      });\n    }\n  }, [dataServers, setContainer, containerUri]);\n\n  return container;\n};\n\nexport default useContainerByUri;\n","import { useMemo } from 'react';\nimport useGetCreateContainerUri from './useGetCreateContainerUri';\n\nconst useCreateContainerUri = (resourceId: string) => {\n  const getCreateContainerUri = useGetCreateContainerUri();\n\n  const createContainerUri = useMemo(() => getCreateContainerUri(resourceId), [getCreateContainerUri, resourceId]);\n\n  return createContainerUri;\n};\n\nexport default useCreateContainerUri;\n","import { useCallback } from 'react';\nimport urlJoin from 'url-join';\nimport useDataServers from './useDataServers';\nimport findCreateContainerWithTypes from '../dataProvider/utils/findCreateContainerWithTypes';\nimport getServerKeyFromType from '../dataProvider/utils/getServerKeyFromType';\nimport useDataModels from './useDataModels';\n\nconst useGetCreateContainerUri = () => {\n  const dataModels = useDataModels();\n  const dataServers = useDataServers();\n\n  const getCreateContainerUri = useCallback(\n    (resourceId: string) => {\n      if (!dataModels || !dataServers || !dataModels[resourceId]) {\n        return undefined;\n      }\n\n      const dataModel = dataModels[resourceId];\n\n      if (dataModel.create?.container) {\n        const [serverKey, path] = Object.entries(dataModel.create.container)[0];\n        if (!serverKey || !dataServers[serverKey]) {\n          throw new Error(`Wrong key for the dataModel.create.container config of resource ${resourceId}`);\n        }\n        return urlJoin(dataServers[serverKey].baseUrl, path);\n      } else if (dataModel.create?.server) {\n        return findCreateContainerWithTypes(dataModel.types, dataModel.create?.server, dataServers);\n      } else {\n        const defaultServerKey = getServerKeyFromType('default', dataServers);\n\n        if (!defaultServerKey) {\n          throw new Error(\n            `No default dataServer found. You can set explicitly one setting the \"default\" attribute to true`\n          );\n        }\n\n        return findCreateContainerWithTypes(dataModel.types, defaultServerKey, dataServers);\n      }\n    },\n    [dataModels, dataServers]\n  );\n\n  return getCreateContainerUri;\n};\n\nexport default useGetCreateContainerUri;\n","import { DataModel, DataServerKey, DataServersConfig } from '../types';\n\nconst findCreateContainerWithTypes = (\n  types: DataModel['types'],\n  createServerKey: DataServerKey,\n  dataServers: DataServersConfig\n) => {\n  if (!dataServers[createServerKey].containers)\n    throw new Error(`Data server ${createServerKey} has no declared containers`);\n\n  const matchingContainers = dataServers[createServerKey].containers.filter(\n    container => container.types?.some(t => types.includes(t))\n  );\n\n  if (matchingContainers.length === 0) {\n    throw new Error(\n      `No container found matching with types ${JSON.stringify(\n        types\n      )}. You can set explicitly the create.container property of the resource.`\n    );\n  } else if (matchingContainers.length > 1) {\n    throw new Error(\n      `More than one container found matching with types ${JSON.stringify(\n        types\n      )}. You must set the create.server or create.container property for the resource.`\n    );\n  }\n\n  return matchingContainers[0].uri;\n};\n\nexport default findCreateContainerWithTypes;\n","import useDataProviderConfig from './useDataProviderConfig';\n\nconst useDataModel = (resourceId: string) => {\n  const config = useDataProviderConfig();\n  return config?.resources[resourceId];\n};\n\nexport default useDataModel;\n","import { useCallback, useMemo, useContext } from 'react';\nimport { DataProviderContext } from 'react-admin';\n\nconst compute = (externalLinks, record) =>\n  typeof externalLinks === 'function' ? externalLinks(record) : externalLinks;\nconst isURL = url => typeof url === 'string' && url.startsWith('http');\n\nconst useGetExternalLink = componentExternalLinks => {\n  // Since the externalLinks config is defined only locally, we don't need to wait for VOID endpoints fetching\n  const dataProvider = useContext(DataProviderContext);\n  const dataServers = dataProvider.getLocalDataServers();\n\n  const serversExternalLinks = useMemo(() => {\n    if (dataServers) {\n      return Object.fromEntries(\n        Object.values(dataServers).map(server => {\n          // If externalLinks is not defined in the data server, use external links for non-default servers\n          const externalLinks = server.externalLinks !== undefined ? server.externalLinks : !server.default;\n          return [server.baseUrl, externalLinks];\n        })\n      );\n    }\n  }, [dataServers]);\n\n  return useCallback(\n    record => {\n      const computedComponentExternalLinks = compute(componentExternalLinks, record);\n      // If the component explicitly asks not to display as external links, use an internal link\n      if (computedComponentExternalLinks === false) return false;\n\n      if (!record?.id) return false;\n\n      const serverBaseUrl = Object.keys(serversExternalLinks).find(baseUrl => record?.id.startsWith(baseUrl));\n      // If no matching data servers could be found, assume we have an internal link\n      if (!serverBaseUrl) return false;\n\n      const computedServerExternalLinks = compute(serversExternalLinks[serverBaseUrl], record);\n      // If the data server explicitly asks not to display as external links, use an internal link\n      if (computedServerExternalLinks === false) return false;\n\n      if (isURL(computedComponentExternalLinks)) {\n        return computedComponentExternalLinks;\n      }\n      if (isURL(computedServerExternalLinks)) {\n        return computedServerExternalLinks;\n      }\n      return record.id;\n    },\n    [serversExternalLinks, componentExternalLinks]\n  );\n};\n\nexport default useGetExternalLink;\n","import { useCallback } from 'react';\nimport useDataProviderConfig from './useDataProviderConfig';\nimport getPrefixFromUri from '../dataProvider/utils/getPrefixFromUri';\n\nconst useGetPrefixFromUri = () => {\n  const config = useDataProviderConfig();\n\n  return useCallback((uri: string) => getPrefixFromUri(uri, config!.ontologies), [config?.ontologies]);\n};\n\nexport default useGetPrefixFromUri;\n","const getPrefixFromUri = (uri: string, ontologies: Record<string, string>) => {\n  for (const [prefix, namespace] of Object.entries(ontologies)) {\n    if (uri.startsWith(namespace)) return uri.replace(namespace, `${prefix}:`);\n  }\n  return uri;\n};\n\nexport default getPrefixFromUri;\n","import React, { useState, useEffect } from 'react';\n\n/**\n * @example\n * <Show>\n *   <FilterHandler\n *     source=\"property\" // ex pair:organizationOfMembership\n *     filter={{\n *       'propertyToFilter':'value'\n *     }} // ex {{'pair:membershipRole':'http://localhost:3000/membership-roles/role-1'}}\n *     >\n *     <SingleFieldList>\n *    </SingleFieldList>\n *   </FilterHandler>\n * </Show>\n */\n\nconst FilterHandler = ({ children, record, filter, source, ...otherProps }) => {\n  const [filtered, setFiltered] = useState();\n  useEffect(() => {\n    if (record && source && Array.isArray(record?.[source])) {\n      const filteredData = record?.[source].filter(r => {\n        let eq = true;\n        for (const key in filter) {\n          const value = r[key];\n          if (Array.isArray(value)) {\n            if (!value.includes(filter[key])) {\n              eq = false;\n            }\n          } else if (value !== filter[key]) {\n            eq = false;\n          }\n        }\n        return eq;\n      });\n      const newRecord = {\n        ...record\n      };\n      // undefined setted if no data to obtain no render in RightLabel or equivalent\n      newRecord[source] = filteredData.length > 0 ? filteredData : undefined;\n      setFiltered(newRecord);\n    }\n  }, [record, source, filter]);\n\n  return (\n    <>\n      {React.Children.map(children, (child, i) => {\n        return React.cloneElement(child, {\n          ...otherProps,\n          record: filtered,\n          source\n        });\n      })}\n    </>\n  );\n};\nexport default FilterHandler;\n","import React from 'react';\nimport { useGetList, useRecordContext } from 'react-admin';\nimport { default as FilterHandler } from './FilterHandler';\n\n/*\n * @example Label used in examples\n *  const Label = ({label, ...otherProps})=>{\n *     return <h2>{label}</h2>\n *  }\n *\n * @example show header for each group with group property thanks to groupHeader\n * <GroupedReferenceHandler\n *   source=\"property\" // predicat of main record to show / ex pair:organizationOfMembership\n *   groupReference=\"RAresource\" // React-Admin resource reference. this is the \"group by\" ressource. / ex MembershipRole\n *   groupHeader={({group,...otherProps}) => <Label {...otherProps} label={group['pair:label']}></Label> }\n *   filterProperty=\"property of source filtered by groupReference\"\n * >\n *   <ArrayField source=\"property\"> // same props as GroupedArrayField source\n *    <ImageList>\n *    </ImageList>\n *   </ArrayField>\n * </GroupedReferenceHandler>\n *\n * @example call chhildren with label thanks to groupLabel\n * <GroupedReferenceHandler\n *   source=\"property\" // predicat of main record to show / ex pair:organizationOfMembership\n *   groupReference=\"RAresource\" // React-Admin resource reference. this is the \"group by\" ressource. / ex MembershipRole\n *   groupLabel=\"property of RAresource display\" // property of React-Admin resource to display. children call whith props \"label\" filled by groupLabel property of groupReference\n *   filterProperty=\"property of source filtered by groupReference\"\n * >\n *   <Label>\n *   <ArrayField source=\"property\"> // same props as GroupedArrayField source\n *    <ImageList>\n *    </ImageList>\n *   </ArrayField>\n * </GroupedReferenceHandler>\n *\n * @example conditional show of group if no data in source. Conditionale groupHeader is not possible because GroupedArrayField define group before filter ; need use chhildren.\n * const ConditionalSourceDefinedHandler = ({record,source,children,...otherProps})=>{\n *   if (record?.[source] && (!Array.isArray(record[source])||record[source].length>0)){\n *     return  React.Children.map(children, (child, i) => {\n *         return React.cloneElement(child, {...otherProps,record,source});\n *       })\n *   }else{\n *     return <></>\n *   }\n * }\n *\n * <GroupedReferenceHandler\n *   source=\"property\" // predicat of main record to show / ex pair:organizationOfMembership\n *   groupReference=\"RAresource\" // React-Admin resource reference. this is the \"group by\" ressource. / ex MembershipRole\n *   groupLabel=\"property of RAresource display\" // property of React-Admin resource to display. children call whith props \"label\" filled by groupLabel property of groupReference\n *   filterProperty=\"property of source filtered by groupReference\"\n * >\n *  <ConditionalSourceDefinedHandler>\n *   <Label>\n *   <ArrayField source=\"property\"> // same props as GroupedArrayField source\n *    <ImageList>\n *    </ImageList>\n *   </ArrayField>\n *  </ConditionalSourceDefinedHandler>\n * </GroupedReferenceHandler>\n *\n *\n */\nconst GroupedReferenceHandler = ({\n  children,\n  groupReference,\n  groupLabel,\n  groupHeader,\n  filterProperty,\n  ...otherProps\n}) => {\n  const record = useRecordContext();\n  const { data } = useGetList(groupReference);\n\n  return (\n    <>\n      {data?.map((data, index) => {\n        const filter = {};\n        filter[filterProperty] = data.id;\n        return (\n          <>\n            {groupHeader && groupHeader({ ...otherProps, group: data })}\n            <FilterHandler {...otherProps} record={record} filter={filter} label={data[groupLabel]}>\n              {children}\n            </FilterHandler>\n          </>\n        );\n      })}\n    </>\n  );\n};\n\nexport default GroupedReferenceHandler;\n","import React, { useEffect, useState } from 'react';\nimport { ArrayInput, SimpleFormIterator, TextInput } from 'react-admin';\nimport makeStyles from '@mui/styles/makeStyles';\n\nconst useReferenceInputStyles = makeStyles({\n  form: {\n    display: 'flex'\n  },\n  input: {\n    paddingRight: '20px'\n  }\n});\n\nconst useHideInputStyles = makeStyles({\n  root: {\n    display: 'none'\n  }\n});\n\nconst ReificationArrayInput = props => {\n  const { reificationClass, children, ...otherProps } = props;\n  const flexFormClasses = useReferenceInputStyles();\n  const hideInputStyles = useHideInputStyles();\n\n  return (\n    <ArrayInput {...otherProps}>\n      <SimpleFormIterator classes={{ form: flexFormClasses.form }}>\n        {React.Children.map(props.children, (child, i) => {\n          return React.cloneElement(child, {\n            className: flexFormClasses.input\n          });\n        })}\n        <TextInput className={hideInputStyles.root} source=\"type\" initialValue={reificationClass} />\n      </SimpleFormIterator>\n    </ArrayInput>\n  );\n};\n\nexport default ReificationArrayInput;\n","import { fetchUtils } from 'react-admin';\nimport arrayOf from '../dataProvider/utils/arrayOf';\nimport { FetchFn } from '../dataProvider/types';\n\ninterface CreateSolidChannelOptions {\n  type: string;\n  closeAfter?: number;\n  startIn?: number;\n  startAt?: string;\n  endAt?: string;\n  rate?: number;\n}\n\n/**\n * Find the solid notification description resource for a given resource URI.\n */\nconst findDescriptionResource = async (authenticatedFetch: FetchFn, resourceUri: string) => {\n  const { headers } = await authenticatedFetch(resourceUri, { method: 'HEAD' });\n  const linkHeader = headers.get('Link');\n\n  const matches = linkHeader?.match(\n    /<([^>]+)>;\\s*rel=\"(?:describedby|http:\\/\\/www\\.w3\\.org\\/ns\\/solid\\/terms#storageDescription)\"/\n  );\n  if (!matches?.[1]) {\n    return undefined;\n    // matches[1] contains the URI of the description resource\n    // Further actions can be taken here, such as subscribing to the websocket using the description resource URI\n  }\n  // Don't use authenticatedFetch to get this endpoint\n  const response = await fetch(matches[1], { headers: new Headers({ Accept: 'application/ld+json' }) });\n  return await response.json();\n};\n\nconst createSolidNotificationChannel = async (\n  authenticatedFetch: FetchFn,\n  resourceUri: string,\n  options: CreateSolidChannelOptions = { type: 'WebSocketChannel2023' }\n) => {\n  const { type, closeAfter, startIn, rate } = options;\n  let { startAt, endAt } = options;\n  if (startIn && !startAt) startAt = new Date(Date.now() + startIn).toISOString();\n  if (closeAfter && !endAt) endAt = new Date(Date.now() + closeAfter).toISOString();\n\n  const descriptionResource = await findDescriptionResource(authenticatedFetch, resourceUri);\n\n  // TODO: use a json-ld parser / ldo in the future for this...\n  // Get solid notification subscription service for the given type.\n  const subscriptionService = (\n    await Promise.all(\n      // Get the subscription service resources (that describe a channel type).\n      arrayOf(descriptionResource.subscription || descriptionResource['notify:subscription']).map(\n        async subscriptionServiceOrUri => {\n          // They might not be resolved...\n          if (typeof subscriptionServiceOrUri === 'string') {\n            // Don't use authenticatedFetch to get this endpoint\n            const response = await fetch(subscriptionServiceOrUri, {\n              headers: new Headers({ Accept: 'application/ld+json' })\n            });\n            return await response.json();\n          }\n          return subscriptionServiceOrUri;\n        }\n      )\n    )\n  ).find((service: any) => {\n    // Find for the correct channel type (e.g. web socket).\n    const channelType = service.channelType ?? service['notify:channelType'];\n    return channelType === type || channelType === `notify:${type}`;\n  });\n\n  if (!subscriptionService) {\n    throw new Error(`No solid notification subscription service found for type ${type}`);\n  }\n\n  // Create a new channel.\n  const { json: channel } = await authenticatedFetch(subscriptionService.id || subscriptionService['@id'], {\n    method: 'POST',\n    body: JSON.stringify({\n      '@context': 'https://www.w3.org/ns/solid/notifications-context/v1',\n      type: 'WebSocketChannel2023',\n      topic: resourceUri,\n      startAt,\n      endAt,\n      rate\n    })\n  });\n\n  return channel;\n};\n\nconst createWsChannel = async (\n  authenticatedFetch: FetchFn,\n  resourceUri: string,\n  options: CreateSolidChannelOptions\n) => {\n  const channel = await createSolidNotificationChannel(authenticatedFetch, resourceUri, options);\n  const receiveFrom: string = channel.receiveFrom || channel['notify:receiveFrom'];\n\n  return new WebSocket(receiveFrom);\n};\n\nconst registeredWebSockets = new Map<string, WebSocket | Promise<WebSocket>>();\n\n/**\n * @param authenticatedFetch A react admin fetch function.\n * @param resourceUri The resource to subscribe to\n * @param options Options to pass to @see createSolidNotificationChannel, if the channel does not exist yet.\n * @returns {WebSocket} A new or existing web socket that subscribed to the given resource.\n */\nconst getOrCreateWsChannel = async (\n  authenticatedFetch: FetchFn,\n  resourceUri: string,\n  options: CreateSolidChannelOptions = { type: 'WebSocketChannel2023', closeAfter: 1000 * 60 * 60 }\n) => {\n  const socket = registeredWebSockets.get(resourceUri);\n  if (socket) {\n    // Will resolve or is resolved already.\n    return socket;\n  }\n\n  // Create a promise, to return immediately and set the sockets cache.\n  // This prevents racing conditions that create multiple channels.\n  const wsPromise = createWsChannel(authenticatedFetch, resourceUri, { ...options, type: 'WebSocketChannel2023' }).then(\n    ws => {\n      // Remove the promise from the cache, if it closes.\n      ws.addEventListener('close', e => {\n        registeredWebSockets.delete(resourceUri);\n      });\n      // Close the socket, if the endAt / closeAfter time is reached.\n      const closeIn = options.closeAfter ?? (options.endAt && new Date(options.endAt).getTime() - Date.now());\n      if (closeIn)\n        setTimeout(() => {\n          ws.close();\n        }, closeIn);\n\n      return ws;\n    }\n  );\n\n  registeredWebSockets.set(resourceUri, wsPromise);\n  return wsPromise;\n};\n\nexport { getOrCreateWsChannel, createWsChannel, createSolidNotificationChannel };\n"],"names":[],"version":3,"file":"index.es.js.map"}
